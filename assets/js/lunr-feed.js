var hostname = "https://pyartez.github.io";
var index = lunr(function () {
    this.field('title')
    this.field('content', {boost: 10})
    this.field('category')
    this.field('tags')
    this.ref('id')
});



    index.add({
      title: "Fostering a Culture of Continuous Learning and Improvement: A Comprehensive Guide for Engineering Managers",
      category: ["management"],
      content: "In the dynamic and evolving field of engineering, sustaining a culture of continuous learning and improvement is crucial. It is the cornerstone for innovation, adaptability, and ongoing success. However, fostering such a culture requires thoughtful, intentional efforts, and a conducive environment from engineering management.\n\nUnderstanding Continuous Learning and Improvement\nContinuous learning and improvement signify the ongoing effort to acquire knowledge and enhance skills, coupled with the iterative process of refining methods, practices, and systems to attain higher efficiency and effectiveness. In engineering management, it involves both individual professional development and organizational advancement.\n\n1. Building a Foundation for Continuous Learning\n\n\n  \n    Create a Supportive Learning Environment: An environment that values learning is the bedrock for continuous improvement. Encourage curiosity, embrace new ideas, and value constructive feedback. Creating an environment where learning is associated with growth and success motivates teams to pursue knowledge actively.\n  \n  \n    Set Clear Expectations and Goals: Clear, attainable learning objectives set the direction for improvement. Goals should be aligned with both individual aspirations and organizational needs, providing a roadmap for professional development.\n  \n\n\n2. Encouraging Individual Learning\n\n\n  \n    Foster Intrinsic Motivation: Intrinsic motivation is a powerful driver for learning. Cultivate a sense of autonomy, mastery, and purpose among team members. Recognize their efforts and achievements, fostering a sense of accomplishment and motivating further learning.\n  \n  \n    Provide Learning Resources and Opportunities: Offering access to learning resources, courses, workshops, and conferences empowers employees to take charge of their learning journey. Encourage knowledge sharing sessions and create a repository of learning materials accessible to all.\n  \n\n\n3. Organizational Learning and Improvement\n\n  \n    Embrace a Growth Mindset: Promote a mindset where challenges are viewed as opportunities to learn, and mistakes are seen as a chance to improve. A growth mindset fosters resilience, adaptability, and a willingness to venture out of the comfort zone.\n  \n  \n    Institutionalize Feedback and Reflection: Regular feedback and reflective practices are pivotal for organizational learning. Conduct retrospectives to analyze projects, derive learnings, and implement improvements. Cultivate a feedback-rich culture where constructive criticism is welcomed and acted upon.\n  \n\n\n4. Driving Innovation through Learning\n\n  \n    Encourage Experimentation: An environment where experimentation is encouraged breeds innovation. Give teams the freedom to try new approaches, learn from failures, and iterate on their ideas. The experimentation-iteration loop is crucial for discovering novel solutions and staying ahead of the curve.\n  \n  \n    Leverage Cross-functional Collaboration: Cross-functional interactions lead to diverse perspectives, enhancing creativity and learning. Encourage collaborations between different departments, fostering a holistic learning environment and spurring multifaceted innovations.\n  \n\n\n5. Utilizing Technology to Facilitate Learning\n\n  \n    Leverage E-Learning Platforms: Online learning platforms offer flexible, diverse learning opportunities. Incorporate e-learning into development plans, allowing team members to learn at their own pace and explore a wide array of topics.\n  \n  \n    Implement Knowledge Management Systems: Knowledge management systems help in organizing and retrieving knowledge efficiently. A well-structured knowledge base enables continuous learning and improvement by providing easy access to information and learnings.\n  \n\n\n6. Measuring Learning and Improvement\n\n  \n    Define Metrics for Learning: To assess the impact of learning initiatives, define clear, measurable learning metrics. Regular assessments ensure that learning objectives are being met and provide insights into areas needing attention.\n  \n  \n    Track Organizational Improvements: Monitor improvements in processes, productivity, and innovations. Assessing the tangible and intangible benefits of learning initiatives validates their efficacy and informs future strategies.\n  \n\n\n7. Sustaining a Learning Culture\n\n  \n    Regularly Revisit Learning Strategies: A dynamic learning culture requires constant refinement. Regularly review and adjust learning strategies based on feedback, assessments, and evolving organizational needs, ensuring sustained relevance and effectiveness.\n  \n  \n    Promote Lifelong Learning: Encourage a perspective where learning is not a one-time activity but a lifelong pursuit. Instilling the value of continuous learning ensures that individuals remain proactive in updating their skills and knowledge throughout their careers.\n  \n\n\nConclusion\nFostering a culture of continuous learning and improvement is an investment in the future. It is about creating a synergistic environment where individual growth fuels organizational advancement, and vice versa. It is not merely about acquiring new knowledge but about creating a mindset of curiosity, adaptability, and relentless pursuit of excellence.\n\nIn a field as dynamic and multifaceted as engineering, the ability to learn, unlearn, and relearn is the linchpin for sustaining success. It is through the amalgamation of individual aspirations and organizational vision that a culture of learning flourishes, paving the way for innovations, enhancements, and sustained excellence in the engineering realm.\n\nIn conclusion, engineering managers who actively cultivate and integrate learning and improvement within the organizational fabric empower their teams to transcend limitations, innovate prolifically, and contribute meaningfully to the evolving tapestry of engineering advancements.\n",
      tags: ["management","culture","learning","progression"],
      id: 0
    });
    

    index.add({
      title: "The Role of Emotional Intelligence in Engineering Management",
      category: ["management"],
      content: "Engineering management is often perceived through a purely technical lens, with emphasis placed on knowledge and expertise in software development, project execution, and technical problem-solving. However, a crucial, albeit frequently overlooked component of successful engineering management, is emotional intelligence (EI). It is the scaffold on which effective leadership is built, fostering positive team dynamics, conflict resolution, and the overall well-being and productivity of engineering teams.\n\nUnderstanding Emotional Intelligence\nEmotional intelligence refers to the ability to understand, manage, and effectively express one’s own feelings, alongside the capacity to engage and navigate successfully with the emotions of others. It comprises five core components:\n\n\n  Self-Awareness: Recognizing one’s own emotions and their impact.\n  Self-Regulation: Managing one’s emotions appropriately.\n  Motivation: Being driven to achieve goals.\n  Empathy: Understanding others’ emotions and responding appropriately.\n  Social Skills: Building rapport and managing relationships.\n\n\nEmotional Intelligence in the Engineering Context\n\nEngineering environments, characterized by logical and analytical thinking, may not intuitively align with the qualitative aspects of emotional intelligence. However, it is precisely within these domains that EI proves indispensable. It enables managers to navigate diverse personalities, mediate conflicts, foster a cooperative team culture, and facilitate effective communication, all pivotal for the seamless execution of projects.\n\nBalancing Technical and People Management\n\nTransitioning from a technical role to a managerial position often involves a paradigm shift from working independently or in small collaborations to overseeing broader, more diverse teams. The focus transforms from solving technical problems to resolving interpersonal ones. Here, EI acts as a fulcrum, balancing technical acuity with interpersonal acumen, promoting harmonious team dynamics, and optimal productivity.\n\n1. Building Strong Teams with EI\nThe synergy between emotional intelligence and team building is undeniable. High EI levels within management play a significant role in fostering positive team relationships, bolstering mutual respect, and creating an inclusive and supportive work environment. Enhanced self-awareness and empathy allow engineering managers to understand team members’ individual needs and motivations better, tailoring their approach to elicit the best from each member.\n\n2. Enhancing Communication\nIn an engineering context, effective communication is paramount. It is not merely about conveying information but about fostering understanding. Managers with high EI are adept at gauging their team’s emotional state and adjusting their communication style accordingly. They understand the importance of clear, concise, and positive communication, especially in high-pressure situations, minimizing misunderstandings and facilitating cooperation.\n\n3. Conflict Resolution and Management\nConflicts are inevitable in any team setting. Engineering managers, armed with emotional intelligence, are equipped to mediate and resolve disputes swiftly and fairly. They can understand differing perspectives, validate feelings without bias, and find common ground, ensuring that conflicts become opportunities for growth rather than sources of disruption.\n\n4. Developing Resilience and Managing Stress\nThe fast-paced and demanding nature of engineering projects can generate high-stress levels. Managers with robust EI can better regulate their emotions, manage stress, and exhibit resilience, maintaining composure and decision-making clarity under pressure. Furthermore, their emotional stability and positivity resonate within the team, fostering a resilient and balanced work environment.\n\n5. Facilitating Professional Development\nProfessional growth in engineering is not solely dependent on technical competence but also on interpersonal skills, leadership ability, and adaptability. Managers with high emotional intelligence can mentor and guide their teams in developing these skills, providing constructive feedback, and supporting their professional evolution.\n\n6. Fostering a Positive Work Culture\nThe influence of a manager’s emotional intelligence extends beyond immediate team interactions, impacting the broader work culture. It creates an environment where openness, collaboration, and mutual respect flourish. Such a positive and inclusive culture is crucial for employee satisfaction, retention, and overall organizational success.\n\nStrategies to Enhance Emotional Intelligence\nEnhancing EI involves intentional effort and ongoing practice. Here are a few strategies that engineering managers can employ:\n\n\n  Regular Reflection: Periodic self-reflection on emotional responses and behavior can improve self-awareness and regulation.\n  Active Listening: Practicing active listening enhances understanding of others’ perspectives and improves empathetic responses.\n  Seeking Feedback: Regularly seeking and valuing feedback from peers and team members can illuminate areas for improvement.\n  Continued Learning: Reading books, attending workshops, or participating in training on emotional intelligence can provide insights and techniques to enhance EI.\n  Mindfulness and Stress Management Techniques: Practices like meditation and mindfulness can improve emotional stability and stress management.\n\n\nConclusion\nIn engineering management, the amalgamation of technical prowess and emotional intelligence creates a dynamic leadership style that accommodates the multifaceted nature of team interaction and project execution. Emotional intelligence is not merely an ancillary skill but a core competency, pivotal for fostering strong, cooperative teams, effective communication, and a positive, inclusive work culture.\n\nBy prioritizing the development of emotional intelligence, engineering managers can enhance not only their leadership effectiveness but also the overall well-being and success of their teams and, by extension, the entire organization. The integration of emotional intelligence within the engineering management paradigm is not just beneficial—it is essential for navigating the complex interpersonal landscapes of the contemporary engineering world.\n",
      tags: ["management"],
      id: 1
    });
    

    index.add({
      title: "Influencing and driving change as an Engineering Manager",
      category: ["management"],
      content: "Change is an inevitable part of business and technology. As an engineering manager, you’re often at the forefront of driving or responding to change, whether it’s adopting a new technology, optimizing processes, or redefining team dynamics. Influencing and driving change successfully requires a blend of technical acumen, leadership skills, and emotional intelligence.\n\nIn this article, we’ll delve into strategies and best practices for influencing and driving change effectively within the domain of engineering management.\n\nUnderstanding the Nature of Change\n\nBefore diving into how to influence and drive change, it’s crucial to understand the nature of change. At its core, change is a shift from a known state to an unknown one. This transition can be met with excitement or resistance depending on various factors like the perceived benefits, fears, or the magnitude of the change.\n\nTypes of Change in Engineering\n\n  Technological Change - Adoption of new technologies or tools.\n  Process Change -  Introduction of new methodologies or optimization of existing processes.\n  Structural Change - Changes in team structures, roles, or responsibilities.\n  Cultural Change - Shifts in team or company values, norms, and behaviors.\n\n\nStrategies for Influencing and Driving Change\n\n1. Develop a Clear Vision - Before you can influence others, you need a clear vision of what the change is and why it’s necessary. This vision serves as a north star, guiding decisions and rallying the team. It’s essential to align this vision with business objectives and broader company goals.\n\n2. Communicate Effectively - \nClear communication is paramount. Ensure everyone understands the reasons for the change, the benefits, and how it will be implemented. Use multiple channels – team meetings, one-on-ones, written documentation – to reinforce the message and cater to different communication preferences.\n\n3. Engage Stakeholders Early - \nIdentify and engage stakeholders early in the process. These are individuals who will be affected by the change or who have influence over its success. By involving them, you gain valuable insights, increase buy-in, and reduce resistance.\n\n4. Lead by Example - \nAs a manager, your team looks to you for guidance. Embrace the change wholeheartedly and demonstrate the behaviors and attitudes you want to see in your team. Your commitment can inspire others to follow suit.\n\n5. Provide Training and Resources - \nEnsure your team has the necessary skills and knowledge to navigate the change. This might involve training sessions, workshops, or providing access to resources.\n\n6. Address Concerns and Resistance - \nResistance is a natural part of the change process. Instead of dismissing concerns, address them head-on. Listen to your team’s fears and hesitations, and provide reassurance or solutions where possible.\n\n7. Celebrate Milestones - \nRecognize and celebrate small wins along the way. This keeps morale high and reinforces the benefits of the change.\n\n8. Stay Adaptable - \nWhile it’s important to have a plan, be prepared to adapt as you receive new information or face unforeseen challenges.\n\nReal-world Scenario: Transitioning to a New Development Methodology\n\nLet’s consider a practical example to illustrate these principles. Imagine you’re an engineering manager aiming to transition your team from a traditional Waterfall development methodology to an Agile approach.\n\n\n  Vision - Start by articulating why Agile is beneficial. Perhaps it’ll allow your team to be more responsive to market changes, improve product quality, or enhance team collaboration.\n  Communication - Hold a team meeting to discuss the transition. Highlight the benefits of Agile, how it contrasts with Waterfall, and the expected outcomes.\n  Stakeholders - Engage senior engineers or team leads early, gather their insights, and enlist their support in championing the change.\n  Lead by Example - Undertake Agile training, actively participate in sprint planning, and demonstrate your commitment to the new methodology.\n  Training - Organize workshops or bring in an Agile coach to train the team in practices like Scrum or Kanban.\n  Address Concerns - Some team members might be concerned about the frequent changes in Agile or the perceived lack of planning. Discuss these concerns openly and provide reassurances or additional training as needed.\n  Celebrate Milestones - Celebrate the completion of the first successful sprint or the release of a product feature using Agile methods.\n  Adaptability - Perhaps certain Agile practices don’t fit your team’s unique context. Stay flexible and be willing to adapt the methodology to suit your team’s needs.\n\n\nConclusion\n\nDriving change as an engineering manager is a blend of strategic planning and emotional intelligence. It requires a compelling vision, clear communication, engagement at all levels, and a willingness to adapt. By understanding the nature of change and applying the strategies discussed, you can navigate transitions more smoothly, ensuring your team’s success and growth in a rapidly evolving tech landscape. Remember, change isn’t just about introducing new tools or processes but fostering a mindset of adaptability, continuous learning, and improvement.\n",
      tags: ["change","management"],
      id: 2
    });
    

    index.add({
      title: "Structuring Your First 1-to-1 as an Engineering Manager",
      category: ["management"],
      content: "Your first 1-to-1 meeting with each team member is a foundational event in your tenure as an engineering manager. It sets the tone for your relationship and is your opportunity to begin building trust, understanding, and alignment. However, this initial meeting can feel somewhat daunting. How do you structure it to ensure it’s effective and beneficial?\n\nThis article explores how to structure your first 1-to-1 meeting as an engineering manager.\n\nUnderstanding the Purpose of a 1-to-1\n\nThe 1-to-1 meeting is a dedicated time for the manager and the employee to have a private, focused conversation. It serves multiple purposes, such as:\n\n\n  Building a personal relationship\n  Discussing progress, challenges, and support\n  Providing and seeking feedback\n  Exploring professional development opportunities\n  Aligning on goals and expectations\n\n\nThe first 1-to-1 meeting with each team member is particularly important as it lays the foundation for these ongoing discussions and your working relationship.\n\nStructuring Your First 1-to-1 Meeting\n\nWhile there is no one-size-fits-all structure for a 1-to-1 meeting, here are some steps you can take to structure your first meeting effectively:\n\n1. Set Clear Objectives\nStart by identifying what you want to achieve in the meeting. This could include getting to know the team member, understanding their role and contributions, discussing their aspirations and concerns, and establishing a communication channel.\n\n2. Allocate Enough Time\nYour first 1-to-1 meeting may take longer than subsequent ones because there’s more ground to cover. Allocate enough time to have a meaningful conversation without rushing - typically, one hour should suffice.\n\n3. Prepare Ahead\nPrepare for the meeting by reviewing the team member’s role, responsibilities, performance, and any previous feedback or issues. Also prepare a list of topics or questions to discuss, focusing on understanding and building a relationship, rather than just tasks and performance.\n\n4. Start With a Personal Connection\nBegin the meeting by building rapport. You could talk briefly about your background and management approach, and express your enthusiasm and expectations for your relationship. Also, encourage them to share about themselves - their interests, experiences, and motivations.\n\n5. Seek Understanding\nSpend a substantial part of the meeting seeking to understand the team member. Ask open-ended questions about their role, accomplishments, challenges, support needs, aspirations, and feedback. Listen attentively and empathetically, and show appreciation for their insights and candor.\n\n6. Share Your Perspective and Expectations\nWhile it’s important to focus on the team member, also share your perspective and expectations as a manager. This could include your objectives, your management style, your expectations for communication and performance, and how you intend to support their success.\n\n7. Discuss Next Steps\nEnd the meeting by discussing the next steps. This could include actions to address any issues or requests, scheduling the next 1-to-1 meeting, or setting goals or priorities for the coming period. Also, reassure them that they can always reach out to you with any concerns, ideas, or requests.\n\n8. Follow Up\nAfter the meeting, follow up promptly on any actions or commitments. This shows that you take the 1-to-1 meeting seriously and that you respect their input and needs.\n\nA Sample Agenda for Your First 1-to-1 Meeting\n\nHere’s a sample agenda to help you structure your first 1-to-1 meeting as an engineering manager:\n\n\n  Introduction (5 minutes)\n  Personal sharing (10 minutes)\n  Discussion about their role, achievements, and challenges (15 minutes)\n  Discussion about their aspirations, concerns, and feedback (15 minutes)\n  Sharing your perspective and expectations (10 minutes)\n  Discussion about next steps and closing (5 minutes)\n\n\nTips for Effective 1-to-1 Meetings\n\n\n  Be present - Focus fully on the team member and the conversation, without distractions or multi-tasking.\n  Be flexible - Adapt the structure and style of the meeting to suit the team member’s needs and preferences.\n  Be respectful - Show respect for the team member’s ideas, emotions, and efforts, and honor their time and confidentiality.\n  Be open - Encourage open, candid communication, and be open to feedback and learning yourself.\n\n\nConclusion\n\nYour first 1-to-1 meeting as an engineering manager is a crucial step towards building a strong, productive relationship with your team members. By structuring the meeting effectively, you can create a positive, beneficial experience that lays the groundwork for ongoing communication, trust, and alignment.\n\nRemember, a 1-to-1 meeting is not just a managerial task, but an opportunity to connect with your team members, appreciate their contributions, and support their success. So, approach these meetings with curiosity, empathy, and dedication, and make the most of the opportunity to influence your team’s performance, satisfaction, and growth.\n",
      tags: ["feedback","management"],
      id: 3
    });
    

    index.add({
      title: "Best Practices for Giving Effective Feedback in Engineering Management",
      category: ["management"],
      content: "Feedback is a fundamental part of management, especially in the field of engineering where precision, continual learning, and improvement are crucial. It is a powerful tool for guiding your team’s performance, fostering professional development, and building strong relationships. However, giving feedback effectively can be a challenging skill to master.\n\nThis article explores the best practices for giving effective feedback in engineering management.\n\nUnderstanding Feedback\n\nFeedback refers to the information that you provide to your team members about their performance, behavior, or outcomes. It can be positive (reinforcing good performance) or constructive (guiding improvements). Feedback is not just about pointing out what’s wrong or right, but about opening a dialogue to promote understanding, learning, and growth.\n\nAs an engineering manager, your role in giving feedback is to guide your team towards achieving their goals and the organization’s objectives, support their professional development, and foster a positive and productive work environment.\n\nBest Practices for Giving Effective Feedback\n\n\n  \n    Be Specific and Clear - Effective feedback is specific and clear, focusing on observable actions or outcomes rather than vague attributes. Instead of saying, “You did a good job,” say, “The way you debugged that complex code issue was impressive. Your systematic approach helped us meet the project deadline.” Specific feedback helps the recipient understand exactly what they did well or need to improve.\n  \n  \n    Be Timely - Feedback is most effective when it is given promptly after the action or outcome. This ensures that the details are fresh in everyone’s mind and allows for immediate learning or reinforcement. However, also consider the recipient’s readiness to receive feedback and the appropriateness of the timing and setting.\n  \n  \n    Focus on the Action, Not the Person - When giving feedback, focus on the action or outcome, not the person. This helps to separate the issue from the individual and prevents the feedback from being perceived as a personal attack. For example, instead of saying, “You are careless,” say, “I noticed there were several errors in the report. Let’s discuss how we can avoid these mistakes in the future.”\n  \n  \n    Use “I” Statements - Using “I” statements, such as “I noticed,” “I feel,” or “I suggest,” can help to make your feedback more objective and less accusatory. It expresses your perspective rather than blaming or making assumptions about the other person.\n  \n  \n    Make it a Two-Way Conversation - Feedback should be a two-way conversation, not a one-way lecture. Encourage the recipient to share their perspective, ask questions, and suggest solutions. This promotes understanding, buy-in, and collaboration.\n  \n  \n    Be Constructive and Forward-Looking - Constructive feedback focuses on improvement and future performance, rather than dwelling on past mistakes. It identifies what can be done differently or better next time and provides guidance or resources to support improvement.\n  \n  \n    Balance Positive and Constructive Feedback - While constructive feedback is important for learning and improvement, positive feedback is equally important for reinforcing good performance and boosting motivation and confidence. Strive for a balanced mix of positive and constructive feedback.\n  \n  \n    Consider the Recipient’s Perspective - Effective feedback is sensitive to the recipient’s perspective, needs, and emotions. Consider their personality, their understanding of the issue, their readiness to receive feedback, and how they might perceive and react to your feedback. Tailor your feedback approach to suit the recipient.\n  \n  \n    Be Genuine and Respectful - Feedback should be genuine, honest, and respectful. Avoid flattery or criticism that is not sincere or warranted. Show respect for the recipient’s feelings, ideas, and efforts, even when you are discussing areas for improvement.\n  \n  \n    Follow Up - Feedback doesn’t end with the conversation. It’s important to follow up to ensure that the feedback has been understood and acted upon. This could involve discussing a plan for improvement, providing resources or support, reviewing progress, or acknowledging improvements.\n  \n\n\nScenarios and Strategies in Engineering Management\n\nLet’s consider a few scenarios related to giving feedback in engineering management and strategies to handle them effectively.\n\nScenario 1: Poor Performance\n\nSuppose an engineer on your team, Alice, is consistently failing to meet her deadlines, causing delays in the project.\n\nStrategy\n\nHave a private conversation with Alice about her performance. Be specific and objective about the issue (“I’ve noticed that the last three tasks have been submitted past the deadline”), and express your concern about its impact on the project. Encourage Alice to share her perspective and challenges. Discuss a plan for improvement and offer your support. Follow up regularly to review progress.\n\nScenario 2: Outstanding Performance\n\nImagine a situation where a junior engineer, Bob, has demonstrated an exceptional performance by solving a complex problem that even senior engineers were struggling with.\n\nStrategy\n\nAcknowledge Bob’s achievement promptly and publicly. Be specific about what he did well (“Your solution to the complex problem was impressive and helped us move forward in the project”). Express your appreciation and confidence in his abilities. This positive feedback will boost Bob’s motivation and confidence and set a positive example for the team.\n\nScenario 3: Unprofessional Behavior\n\nConsider a situation where a team member, Carol, frequently interrupts others during meetings, making some team members feel disrespected and unheard.\n\nStrategy\n\nAddress the issue privately with Carol. Focus on the behavior, not the person (“I’ve noticed that during meetings, there are times when others are interrupted”). Explain its impact on the team. Ask Carol for her perspective and discuss how meetings can be more respectful and inclusive. Follow up to ensure the behavior changes.\n\nConclusion\n\nGiving effective feedback is a critical skill in engineering management. It involves being specific, timely, action-focused, constructive, balanced, considerate, genuine, and respectful. It’s about engaging in a two-way conversation to promote understanding, learning, and growth, and following up to ensure feedback is acted upon.\n\nBy implementing the best practices discussed in this article, you can give feedback effectively, guiding your team’s performance, supporting their professional development, and fostering a positive and productive work environment.\n\nRemember, feedback is not just about correcting mistakes or enforcing standards. It’s about showing your team that you care about their success, growth, and well-being. So, approach feedback with empathy, openness, and dedication, and make a positive difference in your team’s performance, development, and morale.\n",
      tags: ["feedback","management"],
      id: 4
    });
    

    index.add({
      title: "Best Practices for Managing Employee Career Development in Engineering Management",
      category: ["management"],
      content: "The dynamic field of engineering is characterized by rapid technological advancements, shifting market demands, and an ever-evolving professional landscape. Consequently, the career development of engineers is a critical concern for engineering managers. Not only does it impact the satisfaction and retention of the team, but it also influences the long-term success and competitive edge of the organization.\n\nThis article explores the best practices for managing employee career development in engineering management.\n\nUnderstanding Employee Career Development\n\nEmployee career development refers to the progression of an employee’s career goals, skills, knowledge, and experience over time. It involves identifying career paths, setting career goals, acquiring necessary skills, and achieving career milestones. Career development can involve promotions, lateral moves, skill enhancement, or even a change of career direction.\n\nAs an engineering manager, your role in managing career development is to guide, support, and facilitate your team members in their career journeys. It’s about helping them realize their full potential, align their career goals with the organization’s objectives, and navigate the opportunities and challenges in their career paths.\n\nBest Practices for Managing Employee Career Development\n\n\n  \n    Understand Individual Career Aspirations: Every engineer on your team will have unique career aspirations, interests, and values. It’s important to understand these individual differences and consider them in career development planning. Regular one-on-one meetings are a great opportunity to discuss career aspirations, identify career goals, and understand what motivates and interests each team member.\n  \n  \n    Define Clear Career Paths: Career paths in engineering can be diverse and multifaceted, involving different specializations, roles, and levels. Define clear career paths within your organization, outlining the roles, skills, qualifications, and experiences required at each level. This provides a roadmap for your team members to plan and navigate their career progression.\n  \n  \n    Set SMART Career Goals: Career goals should be SMART - Specific, Measurable, Achievable, Relevant, and Time-bound. Work with each team member to set SMART career goals that align with their career aspirations and the organization’s objectives. Regularly review and adjust these goals as needed.\n  \n  \n    Provide Opportunities for Skill Development: Continuous skill development is crucial for career advancement in engineering. Provide opportunities for your team members to learn and develop the skills needed for their career goals. This could involve on-the-job training, workshops, courses, conferences, mentorship, or self-learning resources.\n  \n  \n    Offer Career Development Support: Career development can involve challenges, uncertainties, and transitions. Provide support to your team members throughout their career journeys, helping them make informed career decisions, overcome obstacles, and manage transitions. This could involve career coaching, mentorship, or support from HR or career services.\n  \n  \n    Foster a Culture of Learning and Growth: A culture that values learning and growth encourages continuous career development. Foster this culture by recognizing and rewarding learning and growth, promoting knowledge sharing, and providing a safe environment for experimentation and learning from failure.\n  \n  \n    Facilitate Internal Mobility: Internal mobility, such as lateral moves or promotions within the organization, can provide valuable career development opportunities. Facilitate internal mobility by keeping your team informed about internal opportunities, encouraging them to apply, and supporting them in the transition.\n  \n  \n    Provide Performance Feedback and Career Guidance: Regular performance feedback and career guidance are critical for career development. Provide constructive feedback on your team’s work, highlighting strengths, areas for improvement, and strategies for development. Discuss their career progress, provide guidance on career opportunities and challenges, and help them align their performance with their career goals.\n  \n\n\nScenarios and Strategies in Engineering Management\n\nLet’s look at some scenarios related to career development in engineering management and strategies to handle them effectively.\n\nScenario 1: Skill Development\n\nImagine a situation where an engineer, Alice, is interested in transitioning from a software engineering role to a data science role within your organization.\n\nStrategy\n\nBegin by discussing Alice’s career aspirations and understanding her motivation to transition into data science. Next, identify the skills and experiences required for a data science role, and assess Alice’s current skill set. Create a skill development plan which could include relevant training, courses, or projects. Offer support and resources to help Alice learn and apply these new skills, and provide regular feedback on her progress.\n\nScenario 2: Career Advancement\n\nConsider a situation where a senior engineer, Bob, is eager for career advancement but has been in the same role for several years without a promotion.\n\nStrategy\n\nHave a candid discussion with Bob about his career goals and his expectations for advancement. Review his performance, achievements, and areas for growth. If he’s ready for a higher role, discuss potential opportunities for promotion within the organization. If there are gaps in his skills or performance, provide constructive feedback and help him create a development plan to prepare for advancement.\n\nScenario 3: Career Transition\n\nSuppose a team member, Carol, has been a hardware engineer for several years but is now interested in project management.\n\nStrategy\n\nDiscuss Carol’s career aspirations, understand her interest in project management, and assess her suitability for this role. Identify the skills and experiences required for a project management role, and create a career transition plan. This could involve training in project management, mentoring from an experienced project manager, or involvement in project management tasks. Provide support and resources for Carol to learn and apply new skills, and facilitate her transition into a project management role.\n\nConclusion\n\nManaging employee career development is a complex but rewarding aspect of engineering management. It involves understanding individual career aspirations, defining clear career paths, setting SMART career goals, providing opportunities for skill development, offering career development support, fostering a culture of learning and growth, facilitating internal mobility, and providing performance feedback and career guidance.\n\nBy implementing the best practices discussed in this article, you can help your team members navigate their career paths, achieve their career goals, and realize their full potential. Not only will this enhance their job satisfaction and retention, but it will also contribute to the success and competitiveness of your organization.\n\nRemember, every engineer on your team has unique career aspirations, strengths, and potential. As an engineering manager, your role is to unlock this potential and guide your team members in their career journeys. So, embrace this role with empathy, openness, and dedication, and make a positive difference in the careers of your engineers.\n",
      tags: ["development","management"],
      id: 5
    });
    

    index.add({
      title: "Best Practices for Preventing and Managing Employee Burnout in Engineering Management",
      category: ["management"],
      content: "In the fast-paced, high-pressure world of engineering, employee burnout is a real and present danger. Burnout can lead to decreased productivity, lower job satisfaction, and even serious health problems. As an engineering manager, preventing and managing burnout in your team is not only critical for your team’s well-being but also for the success and sustainability of your projects.\n\nThis article will explore the best practices for preventing and managing employee burnout in engineering management.\n\nUnderstanding Employee Burnout\n\nEmployee burnout is a state of physical, emotional, and mental exhaustion caused by prolonged stress at work. It is characterized by feelings of cynicism, detachment from work, and a sense of ineffectiveness. Burnout can lead to decreased productivity, increased absenteeism, and higher turnover rates. In the long term, it can also contribute to serious health problems, including depression, heart disease, and other stress-related conditions.\n\nBest Practices for Preventing Employee Burnout\n\nPreventing burnout is far more effective than trying to treat it after it has occurred. Here are some best practices to help prevent burnout in your engineering team:\n\n\n  \n    Promote a Balanced Workload: One of the main causes of burnout is an excessive workload. As a manager, ensure that work is distributed evenly and that no one is consistently overburdened. Use project management tools to track tasks and deadlines, and regularly check in with your team to monitor their workload.\n  \n  \n    Encourage Regular Breaks and Time Off: Regular breaks, both during the day and in the form of time off or vacations, are crucial for preventing burnout. Encourage your team to take short breaks throughout the day, and ensure they are using their vacation days. Respect their time off by not contacting them about work-related matters unless absolutely necessary.\n  \n  \n    Foster a Positive Work Environment: A positive work environment, characterized by open communication, mutual respect, and recognition of achievements, can significantly reduce stress and prevent burnout. Foster a culture of appreciation and positivity, and address any issues or conflicts promptly and constructively.\n  \n  \n    Provide Opportunities for Professional Growth: Lack of career advancement or skill development can lead to feelings of stagnation and burnout. Provide opportunities for your team members to learn, grow, and take on new challenges. This could be in the form of training, mentorship, or new projects that stretch their skills.\n  \n  \n    Prioritize Work-Life Balance: Promoting a healthy work-life balance is crucial for preventing burnout. This could involve flexible work hours, remote work options, or policies that discourage working outside of work hours. Respect your team’s personal time and encourage them to engage in activities they enjoy outside of work.\n  \n\n\nBest Practices for Managing Employee Burnout\n\nDespite your best efforts to prevent it, burnout can still occur. Here are some strategies for managing burnout in your engineering team:\n\n\n  \n    Recognize the Signs of Burnout: Recognizing the signs of burnout is the first step towards managing it. These signs can include chronic fatigue, decreased productivity, cynicism, increased absenteeism, or health problems. If you notice these signs in a team member, it’s important to address the issue promptly.\n  \n  \n    Open Up a Dialogue: If you suspect a team member is experiencing burnout, initiate a supportive and confidential conversation. Express your concern, ask about their wellbeing, and listen empathetically. Avoid making assumptions or judgments, and reassure them of your support.\n  \n  \n    Implement and Enforce Boundaries: Revisit work schedules, responsibilities, and expectations to ensure they are realistic and sustainable. Implement and enforce boundaries to prevent overwork, such as setting clear start and end times for work, discouraging after-hours emails, and protecting lunch breaks and vacation times.\n  \n  \n    Provide Support and Resources: Offer support and resources to help the employee manage stress and recover from burnout. This could include providing access to mental health resources, offering flexible work arrangements, or connecting them with a mentor or coach.\n  \n  \n    Review and Adjust Workloads: If burnout is a result of an excessive workload, review and adjust the tasks and responsibilities of the affected team member. Consider redistributing tasks, extending deadlines, or bringing in additional help if necessary.\n  \n\n\nScenarios and Strategies in Engineering Management\n\nLet’s consider a few scenarios of burnout in engineering management and strategies to handle them effectively.\n\nScenario 1: High Workload\n\nImagine a situation where a team member, Alice, has been working long hours for several weeks on a critical project and shows signs of burnout.\n\nStrategy\n\nDiscuss the situation with Alice, expressing your concern and asking about her well-being. Review her workload and identify tasks that could be redistributed, postponed, or eliminated. Enforce work boundaries, such as limiting overtime and ensuring she takes regular breaks and time off. Provide support and resources to help her recover and manage stress.\n\nScenario 2: Lack of Career Advancement\n\nConsider a situation where a senior engineer, Bob, is feeling stuck in his role and is showing signs of burnout.\n\nStrategy\n\nHave a career development conversation with Bob, discussing his career goals, interests, and skills. Identify opportunities for growth or advancement, such as new projects, training, or mentorship. Recognize and value his contributions, and ensure he has a clear path for career progression.\n\nScenario 3: Negative Work Environment\n\nSuppose a team is working in a high-pressure, negative work environment, leading to widespread burnout.\n\nStrategy\n\nAddress the negative factors in the work environment, such as high pressure, lack of communication, or lack of recognition. Foster a positive, supportive culture by promoting open communication, mutual respect, and recognition of achievements. Provide team-building activities and resources for managing stress and improving team dynamics.\n\nConclusion\n\nPreventing and managing employee burnout is a crucial responsibility of engineering managers. It involves fostering a positive work environment, promoting work-life balance, and providing support and resources for stress management and professional growth.\n\nBy understanding the causes and signs of burnout and applying the strategies discussed in this article, you can protect your team’s well-being, improve their job satisfaction, and enhance their productivity and performance.\n\nRemember, a healthy, engaged team is not just beneficial for the individuals, but it’s also critical for the success of your projects and the sustainability of your organization. So, make the prevention and management of burnout a top priority in your engineering management practice.\n",
      tags: ["burnout","management"],
      id: 6
    });
    

    index.add({
      title: "Best Practices for Handling Difficult Conversations in Engineering Management",
      category: ["management"],
      content: "In the dynamic field of engineering management, difficult conversations are inevitable. Whether it’s delivering critical feedback, discussing a project setback, or addressing a conflict between team members, these conversations can be challenging. However, when handled effectively, they can lead to improved performance, stronger relationships, and a more productive work environment.\n\nThis article will explore best practices for handling difficult conversations in engineering management.\n\nUnderstanding Difficult Conversations\n\nDifficult conversations are those that involve high stakes, differing opinions, and strong emotions. They can occur in various situations, such as performance reviews, conflict resolution, change management, or job terminations.\n\nWhile these conversations can be uncomfortable, they are essential for addressing issues, making decisions, and driving progress. As an engineering manager, your ability to handle difficult conversations effectively can significantly impact your team’s success.\n\nBest Practices for Handling Difficult Conversations\n\n\n  \n    Prepare Ahead: Before initiating a difficult conversation, take time to prepare. Understand the issue at hand, clarify your objectives for the conversation, and anticipate the other person’s perspective and possible reactions. If necessary, gather relevant facts, data, or examples to support your points.\n  \n  \n    Choose the Right Time and Place: Timing and location can significantly influence the outcome of a difficult conversation. Choose a time when both parties are calm and not rushed. Select a private, neutral location to ensure confidentiality and minimize distractions.\n  \n  \n    Start the Conversation Positively: Begin the conversation on a positive note. You might express appreciation for the person’s work, acknowledge their feelings, or affirm the importance of your relationship with them. This can help reduce defensiveness and set a constructive tone for the conversation.\n  \n  \n    Be Clear and Direct: Clearly express your concerns or feedback, focusing on the issue and not the person. Be direct, but also considerate of the other person’s feelings. Avoid blame, exaggeration, or assumptions.\n  \n  \n    Listen Actively: Active listening involves fully focusing on the speaker, showing empathy, and clarifying understanding. It shows respect for the other person’s perspective and helps you understand their feelings and concerns.\n  \n  \n    Manage Emotions: Difficult conversations can trigger strong emotions. Be aware of your emotions and the other person’s emotions. Stay calm, patient, and composed, even if the other person becomes upset. If emotions escalate, consider taking a break and resuming the conversation later.\n  \n  \n    Seek Solutions Collaboratively: Rather than imposing your solution, involve the other person in problem-solving. Ask for their ideas or suggestions. This can lead to better solutions and increase their commitment to the action plan.\n  \n  \n    Follow Up: After the conversation, follow up to check on progress, provide support, or clarify any issues. This shows your commitment to resolving the issue and maintaining a positive relationship.\n  \n\n\nScenarios and Strategies in Engineering Management\n\nLet’s consider a few scenarios where difficult conversations are particularly crucial in engineering management, along with strategies to handle them effectively.\n\nScenario 1: Providing Critical Feedback\n\nImagine you have to provide feedback to a team member, Alex, about his performance, which has been below expectations.\n\nStrategy\n\nPrepare by gathering specific examples of Alex’s performance issues. Start the conversation positively, perhaps by acknowledging Alex’s efforts or past contributions. Then, clearly and directly express your concerns, using the examples to illustrate your points. Listen to Alex’s perspective, manage emotions, and collaboratively seek solutions.\n\nScenario 2: Discussing Project Setbacks\n\nSuppose a project your team is working on has encountered significant setbacks, and you need to discuss this with your team.\n\nStrategy\n\nPrepare by understanding the causes of the setbacks and possible solutions. Start the conversation by acknowledging the team’s hard work and expressing confidence in their abilities. Clearly explain the situation, the implications, and your proposed solutions. Encourage open discussion, listen to your team’s ideas and concerns, and collaboratively decide on the next steps.\n\nScenario 3: Addressing Conflict\n\nConsider a situation where two team members, Lisa and Mark, are in conflict, affecting team morale and productivity.\n\nStrategy\n\nPrepare by understanding the nature of the conflict and the perspectives of both Lisa and Mark. Arrange a private meeting with them, starting the conversation on a positive note by acknowledging their value to the team. Encourage each of them to express their feelings and viewpoints, facilitate active listening, and guide them towards a mutually acceptable solution.\n\nScenario 4: Delivering Bad News\n\nSuppose you have to inform your team about budget cuts that will affect resources and possibly lead to layoffs.\n\nStrategy\n\nPrepare thoroughly by understanding the reasons for the budget cuts, their implications, and the plan moving forward. Choose the right time and place, and deliver the news clearly and directly, while expressing empathy for the impact on the team. Allow space for reactions, answer questions honestly, and involve the team in planning how to manage the new circumstances.\n\nOvercoming Common Challenges in Difficult Conversations\n\nDifficult conversations pose various challenges, from managing emotions to overcoming communication barriers. Here are a few common challenges and tips to overcome them:\n\n\n  Fear of Reactions: You may fear the other person’s reactions, such as anger, upset, or defensiveness. Overcome this by preparing for the conversation, managing your emotions, and using effective communication skills to express your concerns constructively.\n  Avoidance: You may be tempted to avoid difficult conversations due to discomfort or fear of conflict. Overcome this by recognizing the importance of these conversations for resolving issues and improving relationships.\n  Lack of Skills: You may lack the necessary communication or conflict resolution skills to handle difficult conversations effectively. Improve these skills through training, practice, or mentoring.\n  Emotional Overload: Difficult conversations can be emotionally draining, leading to stress or burnout. Manage this by practicing self-care, developing emotional intelligence, and seeking support when needed.\n\n\nConclusion\n\nHandling difficult conversations is a crucial competency for engineering managers. It involves a delicate balance of clear communication, active listening, emotional intelligence, and collaborative problem-solving.\n\nBy understanding the principles of effective difficult conversations and applying the strategies discussed in this article, you can turn these challenging encounters into opportunities for growth, learning, and relationship building.\n\nRemember, the goal of a difficult conversation is not to win an argument or impose your views, but to understand each other better, address issues constructively, and strengthen relationships. So, the next time you face a difficult conversation, embrace it with confidence, empathy, and openness.\n",
      tags: ["conflict","management"],
      id: 7
    });
    

    index.add({
      title: "Best Practices for Delegating Effectively in Engineering Management",
      category: ["management"],
      content: "Delegation is one of the most critical skills for any manager, especially in the field of engineering. With its inherently collaborative nature and often complex, multifaceted projects, effective delegation can be the difference between a project’s success and failure.\n\nHowever, delegation is more than just offloading tasks. It involves entrusting your team with responsibilities, empowering them, and fostering their growth. Done right, it leads to improved efficiency, team development, and a healthier, more balanced workload for everyone.\n\nThis article will explore best practices for delegating effectively in engineering management.\n\nUnderstanding Delegation\n\nDelegation is the process of assigning tasks or responsibilities to others. In the context of management, it involves distributing tasks among team members based on their skills, interests, and the team’s overall workload.\n\nThe ability to delegate effectively is essential for many reasons. It allows managers to focus on strategic tasks and decision-making. It helps in developing team members’ skills and promoting their professional growth. It also enhances team productivity and efficiency by ensuring that tasks are done by the most competent individuals.\n\nBest Practices for Effective Delegation\n\n\n  \n    Know Your Team: To delegate effectively, you need a deep understanding of your team’s skills, interests, and capacities. This allows you to assign tasks to the most suitable individuals, leading to improved efficiency and job satisfaction. Regular one-on-one meetings, team-building activities, and performance reviews can provide valuable insights into your team’s capabilities and aspirations.\n  \n  \n    Define Tasks Clearly: Each delegated task should be defined clearly. This includes the task’s objectives, expected outcomes, deadlines, and any necessary resources or tools. Avoid vague instructions or assumptions. Ensure the person understands the task and its importance in the broader project context.\n  \n  \n    Match Tasks to Skills: Assign tasks based on team members’ skills and development goals. This not only increases the chances of the task being done well, but also motivates individuals by showing trust in their abilities and providing opportunities for growth.\n  \n  \n    Delegate Authority Along with Responsibility: Delegation is not just about assigning tasks; it’s also about entrusting authority. When you delegate a task, ensure the person has the authority to make decisions related to it. This empowers your team members, fosters their problem-solving skills, and reduces bottlenecks.\n  \n  \n    Set Clear Expectations: Ensure your team members know what is expected of them. This includes the quality of work, deadlines, and the degree of autonomy they have. Setting clear expectations upfront can prevent misunderstandings and ensure accountability.\n  \n  \n    Monitor Progress, Don’t Micromanage: While it’s important to monitor progress and provide support, avoid micromanaging. Give your team members the freedom to complete tasks in their own way. Regular check-ins or status updates can help keep you informed without being intrusive.\n  \n  \n    Provide Feedback and Recognize Efforts: Provide constructive feedback to help your team members improve. Recognize their efforts and celebrate successes. This not only boosts morale, but also promotes a culture of continuous learning and improvement.\n  \n  \n    Foster a Safe Environment for Mistakes: Mistakes are an inevitable part of learning. Foster an environment where mistakes are seen as learning opportunities, not failures. Encourage your team to take risks, experiment, and learn from their mistakes.\n  \n\n\nDelegation Scenarios and Strategies in Engineering Management\n\nLet’s consider a few scenarios where delegation is particularly crucial in engineering management, along with strategies to handle them effectively.\n\nScenario 1: Large-Scale Projects\n\nLarge-scale engineering projects involve numerous tasks and responsibilities. Effective delegation is crucial for managing such projects successfully.\n\nStrategy\n\nBreak down the project into smaller, manageable tasks. Delegate these tasks based on team members’ skills, interests, and capacities. Ensure each person understands their tasks, the deadlines, and how their work fits into the larger project. Regularly check in on progress and provide support as needed.\n\nScenario 2: High-Stakes Tasks\n\nThere may be high-stakes tasks that carry significant risks or consequences. These tasks require careful delegation to ensure they are handled competently and responsibly.\n\nStrategy\n\nAssign these tasks to individuals with the necessary skills, experience, and judgement. Provide clear guidelines and expectations, and ensure they have all the resources they need. Stay informed about the task’s progress, and be ready to step in if necessary.\n\nScenario 3: Tasks for Skill Development\n\nCertain tasks can provide excellent opportunities for team members to develop new skills or gain experience in different areas.\n\nStrategy\n\nIdentify the skills or experiences that the task can provide, and delegate it to someone who would benefit from this development. Make sure they understand the learning opportunity, and provide support and feedback to aid their learning.\n\nScenario 4: Routine Tasks\n\nRoutine tasks, such as maintenance work or periodic reporting, can take up a significant amount of time if not delegated effectively.\n\nStrategy\n\nConsider delegating routine tasks to less experienced team members as a way to build their skills and free up more experienced members for complex tasks. Alternatively, consider automating these tasks if possible.\n\nOvercoming Common Challenges in Delegation\n\nWhile delegation is crucial for effective management, it can also pose several challenges. Here are a few common challenges and tips to overcome them:\n\n\n  Reluctance to Delegate: Some managers may be reluctant to delegate due to a desire for control, lack of trust in the team, or fear of being seen as lazy. Overcome this by recognizing the value of delegation for the team and the project, building trust with your team, and changing your mindset about delegation.\n  Inadequate Skills or Resources: Sometimes, team members may not have the necessary skills or resources to complete the delegated tasks. Address this by providing training, mentorship, and the necessary tools and resources.\n  Over-delegation: This occurs when too many tasks are delegated to a person, leading to overwhelm and burnout. Avoid this by monitoring your team’s workload and ensuring tasks are distributed evenly.\n  Poor Communication: This can lead to confusion, mistakes, and frustration. Improve communication by clearly defining tasks, setting expectations, and maintaining open lines of communication.\n\n\nConclusion\n\nDelegation is a powerful tool in engineering management. It not only improves efficiency and productivity but also empowers your team, fosters skill development, and creates a more balanced and satisfying work environment.\n\nHowever, effective delegation requires a deep understanding of your team, clear communication, and trust. It’s about striking a balance between providing guidance and giving autonomy, between monitoring progress and avoiding micromanagement.\n\nBy understanding the principles of effective delegation and applying the strategies discussed in this article, you can harness the power of delegation to drive your team’s success and create a supportive, growth-oriented work environment. Remember, delegation is not just about getting things done; it’s about building a strong, capable, and motivated team.\n",
      tags: ["delegating","management"],
      id: 8
    });
    

    index.add({
      title: "Best Practices for Managing Conflict in Engineering Management",
      category: ["management"],
      content: "Conflict is an inevitable part of any organization, and engineering teams are no exception. As an engineering manager, dealing with conflict is one of the most challenging aspects of the role. However, if handled effectively, conflict can lead to innovation, improved team dynamics, and increased productivity. This article will explore best practices for managing conflict in engineering management.\n\nUnderstanding the Nature of Conflict\n\nBefore we delve into conflict management strategies, it’s crucial to understand what conflict is and why it occurs. In the simplest terms, conflict arises from differences. These differences can be in perspectives, interests, or values.\n\nIn the context of an engineering team, conflicts can stem from disagreements over technical decisions, project priorities, or resource allocation. They can also arise from personal differences or communication breakdowns.\n\nRegardless of the cause, conflicts can have significant negative impacts if not addressed. These can include decreased productivity, damaged relationships, increased stress, and a hostile work environment.\n\nAdopting a Proactive Approach\n\nThe first best practice in managing conflict is to adopt a proactive approach. This involves creating an environment where conflicts are less likely to occur and, when they do, they are handled constructively.\n\n\n  Promote Open Communication: Encourage team members to share their ideas, concerns, and feedback openly. Regular team meetings, one-on-ones, and open-door policies can facilitate this.\n  Set Clear Expectations: Make sure your team understands their roles, responsibilities, and the standards expected of them.\n  Encourage Collaboration: Foster a collaborative culture where team members work together and support each other.\n  Provide Training: Provide your team with training in communication, negotiation, and conflict resolution skills.\n  Despite your best efforts, conflicts will inevitably arise. Here are some best practices for managing conflicts when they occur.\n\n\nListen Actively\n\nWhen a conflict arises, the first step is to listen actively to all parties involved. This involves not just hearing the words, but understanding the underlying feelings, needs, and concerns.\n\n\n  Empathize: Try to understand the situation from each person’s perspective.\n  Ask Questions: Ask open-ended questions to get a deeper understanding of the issue.\n  Paraphrase: Paraphrase what you’ve heard to confirm your understanding.\n  Mediate Fairly\n\n\nAs a manager, your role is to mediate the conflict in a fair and neutral manner. Avoid taking sides or making judgments prematurely.\n\n\n  Facilitate Dialogue: Encourage the conflicting parties to communicate directly with each other, expressing their viewpoints respectfully.\n  Focus on Interests, Not Positions: Encourage team members to express their underlying needs and concerns, rather than sticking to their initial positions.\n  Generate Options: Help the parties involved generate multiple options for resolving the conflict.\n\n\nResolve and Learn\n\nOnce a resolution has been reached, it’s crucial to ensure that it’s implemented and the conflict doesn’t recur.\n\n\n  Follow Up: Monitor the situation to ensure that the agreed-upon resolution is implemented.\n  Reflect and Learn: Reflect on the conflict and its resolution. What can be learned? How can similar conflicts be prevented in the future?\n\n\nDon’t Avoid Difficult Conversations\n\nOne of the biggest mistakes managers make is avoiding difficult conversations. However, ignoring conflicts doesn’t make them disappear; it often makes them worse. Address conflicts promptly and directly, while treating all parties with respect and fairness.\n\nLeverage Diversity\n\nDiverse teams bring different perspectives and ideas, which can lead to conflicts. However, this diversity can also be a strength. Encourage your team to see differences as opportunities for learning and innovation, rather than sources of conflict.\n\nSeek Help When Needed\n\nIf a conflict is particularly challenging or if it’s causing significant disruption, don’t hesitate to seek help. This could be from a higher-level manager, a human resources professional, or an external mediator or coach.\n\nKnow When to Escalate\n\nWhile most conflicts can be managed at the team level, there are situations when escalation is necessary. This could be when the conflict involves serious misconduct, such as harassment or discrimination, or when it’s causing significant harm to individuals or the team.\n\nFoster a Culture of Respect\n\nAt the heart of effective conflict management is a culture of respect. This involves treating each other with kindness and understanding, even when disagreements occur. It also involves respecting diversity and different viewpoints.\n\nThe Role of Emotional Intelligence\n\nEmotional Intelligence (EQ) plays a crucial role in conflict management. This includes self-awareness, self-regulation, empathy, and social skills.\n\n\n  Self-Awareness: Recognize your own emotions and how they can impact your reactions to conflict.\n  Self-Regulation: Manage your emotions effectively to remain calm and composed during conflicts.\n  Empathy: Understand and share the feelings of others, which can help de-escalate conflicts.\n  Social Skills: Use effective communication and interpersonal skills to manage and resolve conflicts.\n\n\nBalancing Assertiveness and Cooperation\n\nManaging conflict effectively requires a balance of assertiveness and cooperation. This involves standing up for your own or your team’s needs and interests, while also seeking to understand and accommodate the needs of others.\n\nPromote Psychological Safety\n\nPsychological safety is a sense of trust and respect among team members, where individuals feel safe to express their ideas, take risks, and make mistakes without fear of punishment or ridicule. Teams with high psychological safety are more likely to handle conflicts constructively, as team members feel safe to express their disagreements openly and respectfully.\n\nCommon Conflict Scenarios and Strategies for Resolution\n\nLet’s examine a few common conflict scenarios within engineering teams, and strategies for resolving them effectively.\n\nScenario 1: Disagreement Over Technical Decisions\n\nImagine a situation where two senior engineers, Alice and Bob, have a disagreement over the choice of technology for a new project. Alice believes that adopting a new, cutting-edge technology is the best approach, as it offers advanced features and future-proofs the project. Bob, on the other hand, argues for using a tried-and-true technology that the team is familiar with, to minimize risk and deliver on time.\n\nResolution Strategy\n\nIn this situation, as a manager, your role is to facilitate a constructive dialogue between Alice and Bob. Encourage them to express their viewpoints, focusing on the underlying interests and concerns, rather than sticking to their initial positions.\n\nFor example, Alice’s interest might be in innovation and staying competitive, while Bob’s interest might be in risk management and efficient delivery. Recognizing these underlying interests can open up new options. Perhaps there’s a way to incorporate the new technology in a limited, controlled way that allows for innovation while managing risk. Or maybe the team could invest in training and support to mitigate the risks associated with the new technology.\n\nScenario 2: Personality Clashes\n\nConsider another scenario where two team members, Carlos and David, have a personality clash. Carlos is extroverted, outspoken, and likes to brainstorm ideas in group settings. David is introverted, prefers quiet to concentrate, and likes to think through his ideas before sharing them. Their differing styles have led to tension and misunderstandings.\n\nResolution Strategy\n\nIn this scenario, it’s important to facilitate a conversation between Carlos and David, helping them understand each other’s work styles and needs. Encourage empathy and mutual respect.\n\nFor instance, Carlos could be encouraged to give David a heads-up before discussions and respect his need for quiet working time. David, on the other hand, could be encouraged to express his ideas even if they’re not fully formed, to contribute to the team’s brainstorming sessions.\n\nBy understanding and accommodating each other’s styles, Carlos and David can turn their differences into strengths, fostering a more diverse and inclusive team culture.\n\nScenario 3: Conflict Over Priorities\n\nIn another situation, Emma, a software engineer, feels frustrated because she’s constantly being pulled into urgent bug fixes, leaving her with no time to work on her main project. Frank, the support engineer, feels that resolving customer issues should always be the top priority.\n\nResolution Strategy\n\nIn this case, it’s crucial to clarify roles, responsibilities, and priorities. You may need to step in and make a decision, or facilitate a discussion with Emma and Frank about how to balance immediate customer needs with long-term project goals.\n\nPerhaps there is a way to streamline the bug-fixing process, or allocate specific times for it, so it doesn’t interrupt Emma’s project work. Alternatively, there might be a need for additional resources or better coordination between the project and support teams.\n\nConclusion\n\nManaging conflict in engineering management is a complex task that requires a diverse set of skills, from effective communication and active listening to empathy, patience, and fairness. It’s about creating a culture where conflicts are not feared or avoided, but embraced as opportunities for learning, growth, and innovation.\n\nRemember that conflict is not inherently bad. When handled effectively, it can lead to better decisions, increased creativity, stronger relationships, and a more engaged and productive team. As an engineering manager, your role is not to eliminate conflict, but to manage it constructively, turning challenges into opportunities for team growth and success.\n",
      tags: ["conflict","management"],
      id: 9
    });
    

    index.add({
      title: "Transitioning from Engineer to Engineering Manager: The Uncharted Terrain",
      category: ["management"],
      content: "In the world of tech, transitioning from the role of an engineer to an engineering manager is often viewed as a natural progression. Many engineers, after having honed their technical skills, look forward to the opportunity of expanding their sphere of influence by stepping into a managerial role. However, this transition is not as straightforward as it may seem at first glance. It presents a new set of challenges that are fundamentally different from those encountered in a purely technical role.\n\nUnderstanding the Role Shift: From Problem-Solver to Enabler\n\nOne of the most significant challenges in transitioning from engineer to engineering manager is accepting and understanding the fundamental shift in roles. As an engineer, your primary role is to solve technical problems - whether it’s writing code, debugging issues, or designing software architecture. Your success is often measured by the quality of the solutions you deliver and the technical challenges you overcome.\n\nHowever, as an engineering manager, your role involves less hands-on problem-solving and more enabling your team to solve problems. You become a facilitator, mentor, and guide, helping to clear roadblocks and provide resources for your team. Your success is now measured less by your personal technical accomplishments and more by the achievements of your team.\n\nThis shift from individual contributor to team leader can be challenging and even discomforting for many new managers. It requires a change in mindset, where you need to redefine what productivity and success mean to you. You’ll need to find fulfillment in the success of others, which can be a difficult transition for someone used to personal technical achievements.\n\nMastering the Art of Time Management and Prioritization\n\nAs an engineer, you are often given well-defined tasks and deadlines. Your work is scoped, and you can focus your efforts on technical problem-solving. However, as a manager, your responsibilities become varied and often less defined. You’ll be juggling multiple tasks, from strategic planning and goal-setting to recruitment, team-building, and administrative duties.\n\nConsequently, effective time management and prioritization become essential skills. You’ll need to learn to balance urgent issues with important long-term goals, delegate tasks, and sometimes, even say ‘no’ to avoid overcommitting yourself or your team.\n\nNavigating the Human Element: People Management\n\nPerhaps one of the biggest challenges for many new engineering managers is people management. While your previous role primarily involved interacting with code, your new role will involve interacting with people. Understanding and managing human dynamics is much more complex and unpredictable than solving technical problems.\n\nYou’ll need to cultivate a diverse set of skills, including effective communication, conflict resolution, and motivational abilities. You’ll have to navigate team dynamics, manage conflicting personalities, understand individual motivations, and foster a positive, productive work environment. You’ll also need to provide feedback, mentorship, and career development for your team members - tasks that require empathy, patience, and understanding.\n\nThe Challenge of Delayed Feedback\n\nIn engineering, feedback is often immediate and clear-cut. You write code, run it, and see the results. If something breaks, you fix it. Your impact is visible and quantifiable. However, as a manager, feedback is often delayed and less tangible.\n\nThe impact of decisions you make or initiatives you implement may not be evident for weeks or even months. Measuring success becomes trickier, as it’s often tied to team performance, employee satisfaction, and long-term project outcomes. This delay in feedback can be disconcerting and requires patience, long-term thinking, and an ability to see the big picture.\n\nGrowing into a Visionary Leader\n\nAs an engineer, you are typically tasked with implementing visions and plans created by others. However, as an engineering manager, you are expected to set the vision and chart the course. This involves strategic thinking, decision-making under uncertainty, and the ability to inspire and motivate your team to align with your vision. It requires you to shift from a detail-oriented focus to a broader perspective, which can be challenging for many who are used to the concrete world of coding.\n\nThe Isolated Landscape of Management\n\nBeing a manager can sometimes feel isolating. You’re often privy to sensitive information that you can’t share with your team. There may be company decisions you have to uphold even if you don’t personally agree with them. You may need to mediate conflicts, deliver difficult feedback, or make tough decisions that not everyone will like. This can create a sense of being ‘alone in the middle’ - between your team and upper management - which many new managers are unprepared for.\n\nThe Conquest of the Challenges: Strategies for Success\n\nWhile these challenges might seem daunting, they can be successfully managed with the right strategies.\n\n\n  Embrace the Change: Recognize that your role has fundamentally changed. Embrace your new identity as a facilitator and leader, and take pride in the success of your team.\n  Develop New Skills: Invest time in developing essential managerial skills, such as effective communication, conflict resolution, strategic thinking, and time management. These are just as important as your technical skills in your new role.\n  Seek Mentorship: Find mentors who can guide you through this transition. They can provide invaluable advice, insights, and moral support.\n  Prioritize Self-Care: The role of a manager can be stressful. Make sure to take care of your mental health. Practice mindfulness, maintain a healthy work-life balance, and seek professional help if needed.\n  Embrace Continuous Learning: Accept that you’ll make mistakes, but view them as learning opportunities. Strive to learn and grow continuously.\n\n\nFinal Thoughts\n\nTransitioning from engineer to engineering manager is a significant career shift, filled with challenges but also opportunities for personal and professional growth. It’s a journey that requires not just technical expertise but also a broad range of soft skills.\n\nHowever, it’s important to remember that management is not the only path for career progression. Many companies now offer ‘individual contributor’ tracks, allowing engineers to take on more complex problems and responsibilities without moving into management.\n\nWhether you decide to pursue management or remain an individual contributor, the key is to understand your strengths, passions, and career aspirations, and align them with your chosen path. Remember, a successful career is not just about titles or roles, but about continuous learning, growth, and making a positive impact in your organization.\n\nIn the end, whether you’re writing code or leading a team, the most important thing is to find joy and fulfillment in what you do. This will not only lead to personal satisfaction but also to a successful and rewarding career.\n",
      tags: ["progression","management"],
      id: 10
    });
    

    index.add({
      title: "SOLID Principles in Swift - Dependency Inversion Principle",
      category: ["architecture"],
      content: "Background\n\nIn this series of posts we are going to be covering the SOLID principles of software development. These are a set of principles / guidelines, that when followed when developing a software system, make it more likely that the system will be easier to extend and maintain over time. Let’s take a look at the problems that they seek to solve:\n\n\n  Fragility: A change may break unexpected parts, it is very difficult to detect if you don’t have a good test coverage\n  Immobility: A component is difficult to reuse in another project or in multiple places of the same project because it has too many coupled dependencies\n  Rigidity: A change requires a lot of effort because it affects several parts of the project\n\n\nSo what are the SOLID principles?\n\n\n  Single Responsibility Principle - A class should have only a single responsibility / have only one reason to change\n  Open-Closed Principle - Software should be open for extension but closed for modification\n  Liskov Substitution Principle - Objects in a program should be replaceable with instances of their sub types without altering the correctness of the program\n  Interface Segregation Principle - Many client-specific interfaces are better than one general-purpose interface\n  Dependency Inversion Principle - High level modules should not depend on low level modules. Both should depend on abstractions\n\n\nIn this article we will focus on the Dependency Inversion Principle.\n\nWhat does it mean?\n\nThis principle has 2 main components described below:\n\n\n  High-level modules should not import anything from low-level modules. Both should depend on abstractions (e.g., interfaces)\nAbstractions should not depend on details. Details (concrete implementations) should depend on abstractions\n\n\nI’ve interviewed many iOS developers over the years and I struggle to recall a single person who has actually got this part of the SOLID principles 100% right. I think a large part of this comes from the fact many use simple architectures such as MVVM that don’t break applications down into smaller layers and components/modules. This isn’t a criticism, not every app needs a VIPER/Clean architecture approach with multiple layers.\n\nMost iOS developers I speak to come to the conclusion that this principle just means using protocols instead of concrete classes and injecting dependencies to help with testing/mocking. While this principle does rely on this to work it is not the primary purpose of the principle and exposes an issue once you start to depend on abstractions used across multiple layers / modules.\n\n\n\n\n\n\nSetup\n\nLets setup a simple example in Xcode where we have two separate modules that depend on each other in order to provide some functionality.\n\nIf we create a simple Swift UI project using Xcode, then using File -&gt; New -&gt; Package create 2 new swift packages and add them to the project. One called LibraryA and one called LibraryB. Be sure to select your project in the ‘Add to’ drop down when naming your libraries. You should have something that looks like below Xcode.\n\n\n\nLet’s start by adding a protocol and some custom data structure that we are going to be using across the 2 libraries we are working. Add a file called Protocol.swift in LibraryA and add the following code below:\n\nimport Foundation\n\npublic protocol MyProtocol {\n    func doSomething(data: MyData)\n}\n\npublic struct MyData {\n    public let title: String\n    public let subTitle: String\n}\n\nWe have a simple one function protocol and a small struct, this is what we will be using to separate dependencies between our 2 libraries.\n\nNext, lets create an implementation in LibraryA that has these protocols as a dependency. Create a file in LibraryA with the name ImplementationA:\n\nimport Foundation\n\npublic class ImplementationA {\n    private let something: MyProtocol\n    \n    public init(something: MyProtocol) {\n        self.something = something\n    }\n}\n\nThis is just a simple class that has the MyProtocol protocol has a dependency. Simple enough so far!\n\nNow let’s create a class in LibraryB that implements the protocol that is being used in our class in LibraryA. Create a class in LibraryB called ImplementationB:\n\nimport Foundation\nimport LibraryA\n\npublic class ImplementationB: MyProtocol {\n    public init() {}\n    \n    public func doSomething(data: LibraryA.MyData) {\n        print(\"Do something\")\n    }\n}\n\nWe have our class in LibraryB that is implementing the protocol we previously created in LibraryA. For this reason you will notice that we have to import LibraryA in this class as well. There is one additional step we need to do before this will compile correctly, we need to define our dependency in our package file. Let’s open the LibraryB package file and edit it to add the dependency between the 2 packages:\n\nimport PackageDescription\n\nlet package = Package(\n    name: \"LibraryB\",\n    products: [\n        .library(\n            name: \"LibraryB\",\n            targets: [\"LibraryB\"]),\n    ],\n    // Assign LibraryA as dependency\n    dependencies: [\n        .package(path: \"../LibraryA\")\n    ],\n    targets: [\n        .target(\n            name: \"LibraryB\",\n            // Add dependency to target\n            dependencies: [\"LibraryA\"]),\n        .testTarget(\n            name: \"LibraryBTests\",\n            dependencies: [\"LibraryB\"]),\n    ]\n)\n\nWe won’t go into all the options you need in the swift package file but hopefully by reading this you can see we have defined a dependency and added it to our LibraryB target. If you attempt to build the project it should compile successfully.\n\nNow let’s look at the structure of these 2 libraries and their relationship to each other.\n\n\n\nAs you can see, we have LibraryA, this contains the protocols and LibraryB that implements the protocols. In order for LibraryB to implement the protocols it needs a dependency to LibraryA in order to work.\n\nProblem 1\n\nNow what happens if we want to use the protocols in another Library? Let’s call this LibraryC? At moment the protocols are contained in LibraryA where they are being used and implemented by Library B.\n\n\n  We can’t use the protocols in another library without adding LibraryA which may contain code and other assets we don’t want.\n  We could copy the protocols to LibraryC, however if you needed LibraryA and LibraryC in the same project you would get class clashes.\n  We would need to edit LibraryB to add another dependency in this case. What happens if we are not the owners of LibraryB? How would we even do this?\n\n\nOne solution we can try is moving the protocols from LibraryA to LibraryB. This reverses the dependencies and helps to solve the problems highlighted above. Let’s go ahead and do this now.\n\n\n  Copy the Protocols.swift file we created from LibraryA to LibraryB\n  Remove the import of LibraryA from the implementationB.swift\n\n\nimport Foundation\n\npublic class ImplementationB: MyProtocol {\n    public init() {}\n    \n    public func doSomething(data: MyData) {\n        print(\"Do something\")\n    }\n}\n\n\n  Add an import of LibraryB to the top of implementationA.swift\n\n\nimport Foundation\nimport LibraryB\n\npublic class ImplementationA {\n    private let something: MyProtocol\n    \n    public init(something: MyProtocol) {\n        self.something = something\n    }\n}\n\n\n  Update the LibraryB package file to remove the LibraryA dependency\n\n\nimport PackageDescription\n\nlet package = Package(\n    name: \"LibraryB\",\n    products: [\n        .library(\n            name: \"LibraryB\",\n            targets: [\"LibraryB\"]),\n    ],\n    // Assign LibraryA as dependency\n    dependencies: [],\n    targets: [\n        .target(\n            name: \"LibraryB\",\n            // Add dependency to target\n            dependencies: []),\n        .testTarget(\n            name: \"LibraryBTests\",\n            dependencies: [\"LibraryB\"]),\n    ]\n)\n\n\n  Update the LibraryA package file to add the LibraryB dependency\n\n\nimport PackageDescription\n\nlet package = Package(\n    name: \"LibraryA\",\n    products: [\n        // Products define the executables and libraries a package produces, and make them visible to other packages.\n        .library(\n            name: \"LibraryA\",\n            targets: [\"LibraryA\"]),\n    ],\n    dependencies: [\n        // Dependencies declare other packages that this package depends on.\n        .package(path: \"../LibraryB\")\n    ],\n    targets: [\n        // Targets are the basic building blocks of a package. A target can define a module or a test suite.\n        // Targets can depend on other targets in this package, and on products in packages this package depends on.\n        .target(\n            name: \"LibraryA\",\n            dependencies: [\"LibraryB\"]),\n        .testTarget(\n            name: \"LibraryATests\",\n            dependencies: [\"LibraryA\"]),\n    ]\n)\n\nNow let’s see a diagram of what we have done. Now if we look at our 2 libraries at a high level the dependencies look like this.\n\n\n\nSo now, our LibraryA has a dependency on LibraryB. LibraryA is using the protocols that are defined AND implemented in LibraryB! Problem solved… right… Not entirely.\n\nIf we review the problems we discussed earlier, if LibraryC wanted to make use of the protocols and implementation in LibraryB that is now possible as LibraryB has no knowledge of LibraryA or LibraryC. However this creates a new problem…\n\nProblem 2\n\nWhat if LibraryA and LibraryC want to use different implementations of the protocols from each other? What if we introduced LibraryD that wanted to implement the protocols and be used by another library such as LibraryC? In order to facilitate this we would need to create a dependency between LibraryD and LibraryB. What problems does this create?\n\nWe are introducing a dependency to a library we don’t need, in order to implement the protocols within it. In our example there isn’t much in LibraryB but imagine LibraryB had lots of other code and its own dependencies? Now we are including all of those in our project in order to have access to the protocols.\n\n\n\n\n\n\n\n\nSolution\n\nThis is where Dependency Inversion comes in. What we need to do is create a separate library for the protocols and any data that passes through them. Then, we make the dependencies between our different libraries to that one, thus removing the dependencies between our different layers. Let’s do that now.\n\n\n  Create a new package and add it to your project, naming it Protocols. Now move the Protocols.swift file that we created earlier into the Protocols package. Your Xcode project file explorer should look like below:\n\n\n\n\n\n  Now lets edit the dependencies of our packages so that both LibraryA and LibraryB depend on protocols. Your package files for LibraryA and B should now look like the below:\n\n\nimport PackageDescription\n\nlet package = Package(\n    name: \"LibraryA\",\n    products: [\n        // Products define the executables and libraries a package produces, and make them visible to other packages.\n        .library(\n            name: \"LibraryA\",\n            targets: [\"LibraryA\"]),\n    ],\n    dependencies: [\n        // Dependencies declare other packages that this package depends on.\n        .package(path: \"../Protocols\")\n    ],\n    targets: [\n        // Targets are the basic building blocks of a package. A target can define a module or a test suite.\n        // Targets can depend on other targets in this package, and on products in packages this package depends on.\n        .target(\n            name: \"LibraryA\",\n            dependencies: [\"Protocols\"]),\n        .testTarget(\n            name: \"LibraryATests\",\n            dependencies: [\"LibraryA\"]),\n    ]\n)\n\nimport PackageDescription\n\nlet package = Package(\n    name: \"LibraryB\",\n    products: [\n        // Products define the executables and libraries a package produces, and make them visible to other packages.\n        .library(\n            name: \"LibraryB\",\n            targets: [\"LibraryB\"]),\n    ],\n    dependencies: [\n        // Dependencies declare other packages that this package depends on.\n        .package(path: \"../Protocols\")\n    ],\n    targets: [\n        // Targets are the basic building blocks of a package. A target can define a module or a test suite.\n        // Targets can depend on other targets in this package, and on products in packages this package depends on.\n        .target(\n            name: \"LibraryB\",\n            dependencies: [\"Protocols\"]),\n        .testTarget(\n            name: \"LibraryBTests\",\n            dependencies: [\"LibraryB\"]),\n    ]\n)\n\n\n  Now update the imports of your implementation files so that they import Protocols instead. Your implementation files should look like the below:\n\n\nimport Foundation\nimport Protocols\n\npublic class ImplementationA {\n    private let something: MyProtocol\n    \n    public init(something: MyProtocol) {\n        self.something = something\n    }\n}\n\nimport Foundation\nimport Protocols\n\npublic class ImplementationB: MyProtocol {\n    public init() {}\n    \n    public func doSomething(data: MyData) {\n        print(\"Do something\")\n    }\n}\n\nLet’s have a look at what we have done here. We have moved the dependencies between the layers into a separate package and are now pointing both sides at that rather than one way or the other. Let’s update our diagram to show how this helps us.\n\n\n\nNow if we want to use LibraryA, B, C, or D it does not matter in our dependency graph. They all point to the protocols and data and can be used interchangeably without the need to modify the libraries, so they depend on each other. We also avoid importing any unnecessary classes that we don’t need in order to satisfy the dependencies.\n\nThis is what dependency inversion is. It’s separating protocols and data dependencies from the dependencies themselves and putting them into their own package. This way you completely separate the layers from each other, and they can be used together without any knowledge of each other. Awesome!\n",
      tags: ["swift","architecture"],
      id: 11
    });
    

    index.add({
      title: "SOLID Principles in Swift - Interface Segragation Principle",
      category: ["architecture"],
      content: "Background\n\nIn this series of posts we are going to be covering the SOLID principles of software development. These are a set of principles / guidelines, that when followed when developing a software system, make it more likely that the system will be easier to extend and maintain over time. Let’s take a look at the problems that they seek to solve:\n\n\n  Fragility: A change may break unexpected parts, it is very difficult to detect if you don’t have a good test coverage\n  Immobility: A component is difficult to reuse in another project or in multiple places of the same project because it has too many coupled dependencies\n  Rigidity: A change requires a lot of effort because it affects several parts of the project\n\n\nSo what are the SOLID principles?\n\n\n  Single Responsibility Principle - A class should have only a single responsibility / have only one reason to change\n  Open-Closed Principle - Software should be open for extension but closed for modification\n  Liskov Substitution Principle - Objects in a program should be replaceable with instances of their sub types without altering the correctness of the program\n  Interface Segregation Principle - Many client-specific interfaces are better than one general-purpose interface\n  Dependency Inversion Principle - High level modules should not depend on low level modules. Both should depend on abstractions\n\n\nIn this article we will focus on the Interface Segregation Principle.\n\nWhat does it mean?\n\nThe summary of the principle is as follows:\n\n\n  Many client-specific interfaces are better than one general-purpose interface\n\n\nIn Swift, we use Protocols rather than interfaces in languages such as Java so from here on out we will refer to interfaces as Protocols.\n\nNow the purpose of this rule is quite straight forward in comparison to some of the other rules in the SOLID principles. What it means is its better to create smaller Protocols than to create one large one with lots of methods defined.\n\nWhat’s the problem\n\nSo why does having one large protocol cause a problem? Let’s examine one of the classic Cocoa Touch protocols to see why this is an issue.\n\npublic protocol UITableViewDataSource : NSObjectProtocol {\n\n    // 1\n    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int\n    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell\n\n    // 2\n    optional func numberOfSections(in tableView: UITableView) -&gt; Int\n    optional func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? \n    optional func tableView(_ tableView: UITableView, titleForFooterInSection section: Int) -&gt; String?\n    optional func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -&gt; Bool\n    optional func tableView(_ tableView: UITableView, canMoveRowAt indexPath: IndexPath) -&gt; Bool\n    optional func sectionIndexTitles(for tableView: UITableView) -&gt; [String]?\n    optional func tableView(_ tableView: UITableView, sectionForSectionIndexTitle title: String, at index: Int) -&gt; Int\n    optional func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath)\n    optional func tableView(_ tableView: UITableView, moveRowAt sourceIndexPath: IndexPath, to destinationIndexPath: IndexPath)\n}\n\nI am sure many of you have implemented this protocol at some point in your past ;) I have modified the source slightly to make it easier to read and get the point across So why are we looking at this?\n\n\n  Only 2 methods you have to implement on the first 2.\n  The rest of the methods are optional and you can implement whichever ones you feel you want to use.\n\n\nNow this protocol has its roots in Objective C helps it masks the problem somewhat. In Objective C as you can see in the code above its possible to mark certain functions as optional. This means you can implement them if you want to but don’t have to, this allows this protocol declaration to contain too many methods without causing problems for the implementing class.\n\nIn Swift, it is not possible to mark functions as optional, all functions need to be implemented. Let’s update the above protocol to be more Swifty and see what problems that might cause us.\n\nprotocol MyUITableViewDataSource {\n\n    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int\n    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell\n\n    func numberOfSections(in tableView: UITableView) -&gt; Int\n    func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? \n    func tableView(_ tableView: UITableView, titleForFooterInSection section: Int) -&gt; String?\n    func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -&gt; Bool\n    func tableView(_ tableView: UITableView, canMoveRowAt indexPath: IndexPath) -&gt; Bool\n    func sectionIndexTitles(for tableView: UITableView) -&gt; [String]?\n    func tableView(_ tableView: UITableView, sectionForSectionIndexTitle title: String, at index: Int) -&gt; Int\n    func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath)\n    func tableView(_ tableView: UITableView, moveRowAt sourceIndexPath: IndexPath, to destinationIndexPath: IndexPath)\n}\n\nNow that we have converted our protocol to be more swifty, what problem will this cause when we attempt to make a class conform to this protocol? Let’s have a look at an example.\n\nclass MyTableViewDatasource: MyUITableViewDataSource {\n    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {}\n    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {}\n    func numberOfSections(in tableView: UITableView) -&gt; Int {}\n    func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? {}\n    func tableView(_ tableView: UITableView, titleForFooterInSection section: Int) -&gt; String? {}\n    func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -&gt; Bool {}\n    func tableView(_ tableView: UITableView, canMoveRowAt indexPath: IndexPath) -&gt; Bool {}\n    func sectionIndexTitles(for tableView: UITableView) -&gt; [String]? {}\n    func tableView(_ tableView: UITableView, sectionForSectionIndexTitle title: String, at index: Int) -&gt; Int {}\n    func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath) {}\n    func tableView(_ tableView: UITableView, moveRowAt sourceIndexPath: IndexPath, to destinationIndexPath: IndexPath) {}\n}\n\nOur class above now has to implement every single protocol method. Even if we don’t intend to use it. In the objective c implementation of the protocol we have the option of implementing only the ones we need whereas now we must implement every single method. Imagine all the view controllers in the world that would be full of empty methods in order to conform to this protocol!\n\nThis protocol breaks the interface segregation principle.\n\n\n\n\n\n\nA better solution\n\nTo improve the solution we could break the one big interface down into smaller protocols. That way we could conform to only the protocols we were interested in implementing for our functionality. This may looks something like:\n\n\n  UITableViewDataSource - For the 2 compulsory methods we are familier with\n  UITableViewSectionsDatasource - For methods relating to multi section methods\n  UITableViewSectionTitles - For methods relating to headers and footers in sections\n  UITableViewEditable - For methods relating to editing and moving cells\n\n\nThis way we could conform to select methods we want, rather than one big interface where we may only want a small subset of the methods.\n\nA good example\n\nA good example of interface segregation in the iOS SDK is Codable. The definition of Codable is as below:\n\ntypealias Codable = Decodable &amp; Encodable\n\nBasically Codable is just the combination of 2 other protocols: Decodable and Encodable. This is a great example of how to do the interface segregation. If you are building say a JSON parse struct, you may wish to only conform to Decodable so you can decode the JSON. If in the future you wanted to serialize the struct for something like say data storage you can conform to Encoding later if needed.\n\n\n\n\n\n\nSummary\n\nThe interface segregation principle is the easiest of the principles to understand in my opinion. In basic terms it means don’t create a big protocol with lots of methods that aren’t always required to be implemented depending on the implementation requirements.\n\nInstead, separate the protocol into smaller protocols with only the methods required for a single piece of functionality to work. Not only does this avoids having lots of redundant methods it also helps to facilitate the single responsibility principle by allowing functionality to be broken down into different classes. For example, you could have different classes to handle different activities rather than one big class with all functionality in.\n",
      tags: ["swift","architecture"],
      id: 12
    });
    

    index.add({
      title: "SOLID Principles in Swift - Liskov Substitution Principle",
      category: ["architecture"],
      content: "Background\n\nIn this series of posts we are going to be covering the SOLID principles of software development. These are a set of principles / guidelines, that when followed when developing a software system, make it more likely that the system will be easier to extend and maintain over time. Let’s take a look at the problems that they seek to solve:\n\n\n  Fragility: A change may break unexpected parts, it is very difficult to detect if you don’t have a good test coverage\n  Immobility: A component is difficult to reuse in another project or in multiple places of the same project because it has too many coupled dependencies\n  Rigidity: A change requires a lot of effort because it affects several parts of the project\n\n\nSo what are the SOLID principles?\n\n\n  Single Responsibility Principle - A class should have only a single responsibility / have only one reason to change\n  Open-Closed Principle - Software should be open for extension but closed for modification\n  Liskov Substitution Principle - Objects in a program should be replaceable with instances of their sub types without altering the correctness of the program\n  Interface Segregation Principle - Many client-specific interfaces are better than one general-purpose interface\n  Dependency Inversion Principle - High level modules should not depend on low level modules. Both should depend on abstractions\n\n\nIn this article we will focus on the Liskov Substitution Principle.\n\nWhat does it mean?\n\nSo the Liskov Substitution Principle states:\n\n\n  Derived classes must be substitutable for their base classes\n\n\nWhat exactly does this mean? In a basic sense it for example if you have a function that accepts a type of class which is a parent of other classes, any class that subclasses the parent class should be able to be passed in without it breaking the program.\n\nSee a summary of the main points of the principle below:\n\n\n  Contra variance of method parameter types in the sub type.\n  Covariance of method return types in the sub type.\n  New exceptions cannot be thrown by the methods in the sub type, except if they are sub types of exceptions thrown by the methods of the super type.\n  Don’t implement stricter validation rules on input parameters than those implemented by the parent class.\n  Apply at the least the same rules to all output parameters as applied by the parent class.\n\n\nLet’s take a look at what these different rules mean for subclasses.\n\n\n\n\n\n\nThe Parent Class\n\nFirst of all, let’s define our parent class or base class that contains some functionality. Let’s use a vehicle class as an example, this vehicle has a throttle which can be set at any value between 0 and 100.\n\n// 1\nenum VehicleError: Error {\n    case outOfBounds\n}\n\n// 2\nclass Vehicle {\n    private var throttle: Int = 0\n    \n    // 3\n    func setThrottle(throttle: Int) throws {\n        guard (0...100).contains(throttle) else {\n            throw VehicleError.outOfBounds\n        }\n        self.throttle = throttle\n    }\n}\n\nLet’s step through it:\n\n\n  First of all we define a custom error to throw if the throttle is not within bounds\n  Here we define our vehicle class that has a throttle variable to store the value being set\n  We have a function to set the throttle value, there is a guard statement to check whether the value being set is in the appropriate range. If it is not, we throw an error, if it is we set the value\n\n\nValidation rules on input parameters\n\nNow let’s create a subclass that breaks the principle. We will make a lorry class that inherits from the super class but adds its own restrictions to the throttle function, only allowing the throttle to be set between 0 and 60 for example.\n\nclass Lorry: Vehicle {\n    override func setThrottle(throttle: Int) throws {\n        guard (0...60).contains(throttle) else {\n            throw VehicleError.outOfBounds\n        }\n        \n        try super.setThrottle(throttle: throttle)\n    }\n}\n\nSo what is happening here? We have subclassed the Vehicle class and overriden the setThrottle method. Now what we have done here is we have added a guard statement to check if the throttle is between 0 and 60. We throw an error saying out of bounds if outside of that, if it is within bounds we call the super class method.\n\nWhy is this a problem? Well imagine we are building a system / class that interacts with the Vehicle class. Now based on the Vehicle class you would expect to be able to set the throttle to anything between 0 and a 100. However now, if someone chooses to pass a Lorry subclass to your system / class, you will not be able to set the throttle above 60. Depending on how this other class or system is built this may have unintended side effects as you can’t set the values that you are expecting without getting an error.\n\nThis example breaks the rule:\n\n\n  Don’t implement stricter validation rules on input parameters than those implemented by the parent class.\n\n\nErrors in the liskov principle\n\nLet’s modify our example to see how we could break the principle by throwing different errors. Let’s modify the Lorry subclass:\n\nenum LorryError: Error {\n\tcase outOfBounds\n}\n\nclass Lorry: Vehicle {\n    override func setThrottle(throttle: Int) throws {\n        guard (0...60).contains(throttle) else {\n            throw LorryError.outOfBounds\n        }\n        \n        try super.setThrottle(throttle: throttle)\n    }\n}\n\nSo what is happening here:\n\n\n  We have added a new Error type called LorryError\n  When we have our bounds exception we are throwing this new error type instead of the one provided by the super class\n\n\nWhy does that cause a problem? To find out let’s take a look at the error handling code:\n\n// 1\nlet vehicle: Vehicle = Vehicle()\n\ndo {\n\t// 2\n    try vehicle.setThrottle(throttle: 110)\n} catch VehicleError.outOfBounds {\n\t// 3\n    print(\"System shutdown\")\n} catch {\n\t// 4\n    print(\"Show generic error\")\n}\n\nLet’s step through this code:\n\n\n  We are creating a Vehicle super class object.\n  We are calling our function with a value considered out of bounds\n  We catch the outOfBounds exception and print a system shutdown message\n  We have a generic catch for other errors where we show a generic error message\n\n\nNow if we run this code we see the below message in the console as expected:\n\n\n  System shutdown\n\n\nSo what happens if we replace our Lorry subclass with its new error and put it in place of the Vehicle super class? If we change line one to read:\n\nlet vehicle: Vehicle = Lorry()\n\nIf we run the code above we will now see a different error:\n\n\n  Show generic error\n\n\nThe error handling code is not aware of subclass specific errors so is no longer able to handle them accordingly. Imagine a mission critical system that needs to shut down if an out of bounds happens, in this case the error would be missed as it would require the error handling class to have knowledge of all possible sub types in order to handle all the errors appropriate. Defeating the point of using the super class and thus breaking the principle:\n\n\n  New exceptions cannot be thrown by the methods in the sub type, except if they are sub types of exceptions thrown by the methods of the super type.\n\n\nContra variance and Covariance of parameters and return types\n\nIn the list of rules you may recall seeing two items talking about contra variance and covariance of parameters and return types. What does that mean exactly?\n\n\n  Contra variance of method parameter types in the sub type.\n  Covariance of method return types in the sub type.\n\n\nContra variance of method parameter types in the sub type\n\nContra variance means that we can use change the type of method parameter to a super class of the type but not a subclass. This rules works basically in combination with the rule below:\n\n\n  Don’t implement stricter validation rules on input parameters than those implemented by the parent class.\n\n\nWhat it means is, we can use a super class of a parameter, thus ‘weakening’ the restrictions of the method, but not a subclass of that type which would tighten the restrictions of the method.\n\nCovariance of method return types in the sub type\n\n\n\n\n\n\nCovariance means that the type being used can be a sub type of the class provided by the super class function return type. Similarly, this works in the same way as the 5th rule:\n\n\n  Apply at the least the same rules to all output parameters as applied by the parent class.\n\n\nNow both of these rules aren’t possible to be broken as part of Swift. It’s not possible to overload functions providing alternative type specifications, at least while still referring to the super class type. We can override methods and provide different parameter types and return types but this requires the calling class to know the type of the subclass. When referring to the super class, the super class implementation is always called regardless of subclass functions with different params.\n\n",
      tags: ["swift","architecture"],
      id: 13
    });
    

    index.add({
      title: "SOLID Principles in Swift - Open / Closed Principle",
      category: ["architecture"],
      content: "Background\n\nIn this series of posts we are going to be covering the SOLID principles of software development. These are a set of principles / guidelines, that when followed when developing a software system, make it more likely that the system will be easier to extend and maintain over time. Let’s take a look at the problems that they seek to solve:\n\n\n  Fragility: A change may break unexpected parts, it is very difficult to detect if you don’t have a good test coverage\n  Immobility: A component is difficult to reuse in another project or in multiple places of the same project because it has too many coupled dependencies\n  Rigidity: A change requires a lot of effort because it affects several parts of the project\n\n\nSo what are the SOLID principles?\n\n\n  Single Responsibility Principle - A class should have only a single responsibility / have only one reason to change\n  Open-Closed Principle - Software should be open for extension but closed for modification\n  Liskov Substitution Principle - Objects in a program should be replaceable with instances of their sub types without altering the correctness of the program\n  Interface Segregation Principle - Many client-specific interfaces are better than one general-purpose interface\n  Dependency Inversion Principle - High level modules should not depend on low level modules. Both should depend on abstractions\n\n\nIn this article we will focus on the Open-Closed Principle.\n\nWhat does it mean?\n\nSo the open-closed principle states:\n\n\n  Software should be open for extension but closed for modification\n\n\nWhat exactly does this mean? I think out of all the principles this is the hardest to understand. Mostly due to the fact the explanation leaves far too much open to interpretation. A simple Google search will offer up several examples of how this principle works. In this article I will present my take on the principle and how to build software that will comply with it.\n\nLet’s focus on a type that by design, violates the open closed principle.\n\n\n\n\n\n\nEnums\n\nEnums are a very powerful tool in Swift. They are first class types and such can have associated values and conform to protocols for example. However when used at the boundary of a particular system or module they can present a particular problem.\n\nLet’s imagine an analytics system where we can log events. This is a design pattern I’ve seen in many places:\n\n// 1\nenum AnalyticsEvent {\n    case newsList\n    case newsDetail(id: Int)\n}\n\n// 2\nclass AnalyticsController {\n    func sendEvent(_ event: AnalyticsEvent) {\n        let title = event.title\n        let params = event.params\n        \n        // Send data to analytics network\n    }\n}\n\n// 3\nextension AnalyticsEvent {\n    var title: String {\n        switch self {\n        case .newsList:\n            return \"News List\"\n        case .newsDetail:\n            return \"News detail\"\n        }\n    }\n    \n    var params: [String : String] {\n        switch self {\n        case .newsList:\n            return [:]\n        case .newsDetail(let id):\n            return [\"id\": \"\\(id)\"]\n        }\n    }\n}\n\nLet’s look at what we have here.\n\n\n  The first thing that is defined is an enum that houses all the different analytics events that are available. Some with associated values.\n  Next we have our analytics controller, this takes an event as a parameter, takes information from the event and would then send that on to our analytics system.\n  Here we have extended the AnalyticsEvent enum to add 2 variables, one for title and one for params that contain a switch for each of our events.\n\n\nOn the surface or at first look this might appear an ok solution. We have hidden our implementation of the analytics network inside our AnalyticsController and setup a defined set of events that we can support.\n\nThe Problem\n\nNow lets look at the problems that this approach causes.\n\n\n  What happens if we need to add new events to our analytics system?\n  What if our analytics system was part of a separate package or module?\n  What happens when we have a lot of events?\n\n\nSo first of all, every time we need to add / update or remove any of the events in our analytics system we need to modify the enum. We can’t just implement new events and have them be compatible with the system. Also if the number of events becomes very large then the code will grow large in size. Making it hard to read, maintain and a bit of a mess. Also the enum now has multiple responsibilities, as it covers many events breaking the single responsibility principle.\n\nThe second issue which is probably the more important one, is let’s say we are breaking our app down in to separate packages. This Analytics Controller and Event would be in a separate package, what if we wanted to re-use it across different projects? Both of these scenarios become very difficult because we are using an enum that would need to be updated to accommodate events for different apps. The package would need constantly updating as new events were added.\n\n\n\n\n\n\nThe Solution\n\nSo we have identified some issues with the above implementation, how can we change it to make solve these issues we have identified? Look at the new example:\n\n// 1\nstruct NewsListEvent: AnalyticsEvent {\n    var title: String {\n        return \"News List\"\n    }\n    \n    var params: [String : String] {\n        return [:]\n    }\n}\n\nstruct NewsDetailEvent: AnalyticsEvent {\n    let id: Int\n    \n    var title: String {\n        return \"News detail\"\n    }\n    \n    var params: [String : String] {\n        return [\"id\": \"\\(id)\"]\n    }\n}\n\n// 2\nprotocol AnalyticsEvent {\n    var title: String { get }\n    var params: [String: String] { get }\n}\n\nclass AnalyticsController {\n    func sendEvent(_ event: AnalyticsEvent) {\n        let title = event.title\n        let params = event.params\n        \n        // Send data to analytics network\n    }\n}\n\nLet’s look at how we have changed the example:\n\n\n  \n    First of all we have now removed the enum. Using an enum as a huge list of possible options is considered a code smell. Especially when it involves something that may change often. If you have a finite number of states that is unlikely to change, that is more suited to an enum than a list of analytics events. We have refactored those enum cases into 2 separate classes now.\n  \n  \n    We have switched the enum for a protocol that exposes the necessary items required by our analytics controller (we could have potentially done this in the previous example however we would still have the enum).\n  \n\n\nSo what advantages does this have over the previous implementation?\n\n\n  With the events now being in separate classes we are now following the single responsibility principle, each event has its own class that can be updated whenever they need to be.\n  Now that we are using a protocol and not an enum, we are now able to add new events to our app without ever having to touch the analytics system. Simply create a new class and make it conform to AnalyticsEvent, and we can use it with the analytics controller.\n  Further to that we could have our analytics system in a separate reusable package, then our client apps could define their own set of events to use with the system.\n\n\nOur analytics code is now open for extension, but does not need to be modified to support new events. Unlike our enum example.\n",
      tags: ["swift","architecture"],
      id: 14
    });
    

    index.add({
      title: "SOLID Principles in Swift - Single Responsibility Principle",
      category: ["architecture"],
      content: "Background\n\nIn this series of posts we are going to be covering the SOLID principles of software development. These are a set of principles / guidelines, that when followed when developing a software system, make it more likely that the system will be easier to extend and maintain over time. Let’s take a look at the problems that they seek to solve:\n\n\n  Fragility: A change may break unexpected parts, it is very difficult to detect if you don’t have a good test coverage\n  Immobility: A component is difficult to reuse in another project or in multiple places of the same project because it has too many coupled dependencies\n  Rigidity: A change requires a lot of effort because it affects several parts of the project\n\n\nSo what are the SOLID principles?\n\n\n  Single Responsibility Principle - A class should have only a single responsibility / have only one reason to change\n  Open-Closed Principle - Software should be open for extension but closed for modification\n  Liskov Substitution Principle - Objects in a program should be replaceable with instances of their sub types without altering the correctness of the program\n  Interface Segregation Principle - Many client-specific interfaces are better than one general-purpose interface\n  Dependency Inversion Principle - High level modules should not depend on low level modules. Both should depend on abstractions\n\n\nIn this article we will focus on the Single Responsibility Principle.\n\n\n\n\n\n\nProblem\n\nThe first principle in the list is the Single Responsibility Principle. This principle is defined as follows:\n\n\n  A class should have only one reason to change\n\n\nThis means a class should be responsible for only one task, not multiple. Let’s take a look at an example and how we can refactor it using the principle.\n\nstruct SomeNews: Codable {\n    let id: Int\n    let title: String\n}\n\nclass NewsDatasource {\n    func getNews(completion: @escaping ([SomeNews]) -&gt; Void) {\n        // 1. Create request\n        let url = URL(string: \"SomeNews/URL\")!\n        let request = URLRequest(url: url)\n        \n        // 2. Fetching data\n        let dataTask = URLSession.shared.dataTask(with: request) { (data, response, error) in\n            \n            // 3. Parsing data\n            guard let data = data,\n                  let news = try? JSONDecoder().decode([SomeNews].self, from: data) else {\n                completion([])\n                return\n            }\n            \n            completion(news)\n        }\n        \n        dataTask.resume()\n    }\n}\n\nThis looks like a fairly simple news datasource / service that is fetching some news items from the web. However if we take a closer look we will see it’s responsible for more than one task.\n\n\n  Creating the URLRequest that is used to fetch the news articles\n  Fetching the data using a URLSession\n  Parsing the data\n\n\nAlready that is 3 different responsibilities this class has. They may seem fairly straight forward in this example but imagine how this could get out of hand quickly in a larger codebase. Let’s cover some of the scenarios.\n\n\n  Is this example the news request is simple. However what if the request was more complex, what if we needed to add headers etc to that request? All that code would be in this class.\n  What if we wanted to change the request used to fetch the news? We would have to make a code change here. Or what if we could fetch news from more than one API? How would we do that in the current structure?\n  Once the request has been made we are using a JSONDecoder to decode the response. What if the response comes back in a different format? What if we wanted to use a different decodable for the response?\n  What if the news request can be used in multiple places?\n\n\nAs we can see from the above list, there are several scenarios that would require a code change of this class. If we recall what the single responsibility stands for:\n\n\n  A class should have only one reason to change\n\n\nThere is also a side effect of this which isn’t as obvious, that is testability. Let’s look at some examples:\n\n\n  How would we test changes the URLRequest? If did indeed change the URLRequest or it was being generated differently, how would we test that?\n  How do we test how our class handles responses from the server? What happens if we get an error for example?\n  How do we test our decoding code? How can we be sure that it is going to handle incorrect data correctly? How does our news datasource handle decoding errors?\n\n\nIf we look at the code in the example we can see that in would be impossible to write unit tests covering any of the above scenarios. Let’s have a look at how we can break this class down into single components, allowing us to make changes only in one place and at the same time improving testability.\n\nBreaking it down\n\nURL Builder\n\nLet’s start by breaking this class down into separate classes, each with one responsibility. First of all let’s take out the building of the URLRequest and put it in another class.\n\nclass NewsURLBuilder {\n    private let hostName: String\n    \n    init(hostName: String) {\n        self.hostName = hostName\n    }\n    \n    func getNews() -&gt; URLRequest {\n        let url = URL(string: \"\\(hostName)SomeNews/URL\")!\n        let request = URLRequest(url: url)\n\n        return request\n    }\n}\n\nGreat, now we have a class that’s only responsibility is to build and return a URLRequest. In a more complex system this class might need ids, user tokens etc in order to configure the request. In the scenario where we need to change how news is retrieved we only need to modify this one class in order to make that change. We can also change the hostname based on the environment such as dev, test and prod.\n\nThe other benefit of doing this is we can now write unit tests to make sure that the URLRequest is being built correctly. Let’s do a small example now:\n\nclass URLBuilderTests: XCTestCase {\n\n    func testURLBuilder() throws {\n        let builder = NewsURLBuilder(hostName: \"http://mytest.com/\")\n        let request = builder.getNews()\n        \n        XCTAssertEqual(request.url?.absoluteString, \"http://mytest.com/SomeNews/URL\", \"Request URL string is incorrect\")\n    }\n\n}\n\nOur URL builder isn’t particularly complex so doesn’t need many tests. But at least here with it being in a separate component we can test the construction and make sure it’s being created correctly. We could expand this test to test other elements of the request if needed, or if we needed different parameters to build the request.\n\n\n\n\n\n\nParser\n\nNext lets take the parser and put that into it’s own class.\n\nclass NewsParser {\n    private let decoder: JSONDecoder\n    \n    init(decoder: JSONDecoder) {\n        self.decoder = decoder\n    }\n    \n    func parse(data: Data) -&gt; [SomeNews] {\n        return (try? decoder.decode([SomeNews].self, from: data)) ?? []\n    }\n}\n\nHere we can see we have taken our decoding code and put it into a separate class. This class has one reason to change, it only needs to be changed if the parsing needs to be changed! Also like our URL builder class we can now test the decoding to make sure we get the results we are expecting:\n\nclass NewsParserTests: XCTestCase {\n\n    func testCorrectData() throws {\n        let correctJSON = \"\"\"\n        [\n          {\n            \"id\": 1,\n            \"title\": \"Test Article 1\"\n          },\n          {\n            \"id\": 2,\n            \"title\": \"Test Article 2\"\n          }\n        ]\n        \"\"\"\n        \n        let data = correctJSON.data(using: .utf8)!\n        \n        let parser = NewsParser(decoder: JSONDecoder())\n        let news = parser.parse(data: data)\n        XCTAssertFalse(news.isEmpty)\n        XCTAssertEqual(news[0].id, 1)\n        XCTAssertEqual(news[0].title, \"Test Article 1\")\n    }\n\n    \n    func testInCorrectData() throws {\n        let incorrectJSON = \"\"\"\n        [\n          {\n            \"id\": 1,\n            \"title\": \"Test Article 1\"\n          },\n          {\n            \"id\": 2,\n        ]\n        \"\"\"\n        \n        let data = incorrectJSON.data(using: .utf8)!\n        \n        let parser = NewsParser(decoder: JSONDecoder())\n        let news = parser.parse(data: data)\n        XCTAssertTrue(news.isEmpty)\n    }\n}\n\nSo what have we done here. We have created a couple of unit tests for our parser.\n\n\n  The first one supplies the parser with some correct JSON data and checks that the news objects we receive are correct and have the right data.\n  The second test sends some incorrect data to the parser and tests that we receive an empty array as expected\n\n\nI’m aware that we aren’t handling errors in this example, this has been done to try and keep things as simple as possible\n\n\n\n\n\n\nPutting it all together\n\nNow that we have separated out these components into separate pieces, lets see how our datasource looks now.\n\nclass NewsDatasource {\n    private let requestBuilder: NewsURLBuilder\n    private let parser: NewsParser\n    \n    init(requestBuilder: NewsURLBuilder, parser: NewsParser) {\n        self.requestBuilder = requestBuilder\n        self.parser = parser\n    }\n    \n    func getNews(completion: @escaping ([SomeNews]) -&gt; Void) {\n        // 1. Create request\n        let request = requestBuilder.getNews()\n        \n        // 2. Fetching data\n        let dataTask = URLSession.shared.dataTask(with: request) { [weak self] (data, response, error) in\n            \n            // 3. Parsing data\n            guard let self = self,\n                let data = data else {\n                completion([])\n                return\n            }\n            \n            completion(self.parser.parse(data: data))\n        }\n        \n        dataTask.resume()\n    }\n}\n\nNow if we look here we can see that we have swapped out the code for building the request and parsing the data for our separate classes. Now our example is following the single responsibility principle. We have 3 components now:\n\n\n  A component to build our request\n  A component to execute the request\n  A component to parse the data we get back from the request\n\n\nSo what have we gained:\n\n\n  We now have test coverage of our components (we could update the NewsDatasource to have tests too but that is a bit more advanced and out of scope of this article)\n  We have the ability to re-use these components in other parts of the app or in other apps if we need to\n  If we need to make changes, each component is only responsibility for one thing, so we can update and test each change in turn. Rather than making multiple changes in one place and not be able to test them!\n\n\nFeel free to download the sample and play around with the tests yourself!\n\n\n\n\n\n",
      tags: ["swift","architecture"],
      id: 15
    });
    

    index.add({
      title: "Programmatic routing in SwiftUI",
      category: ["swiftUI"],
      content: "Background\n\nAs I’m sure any iOS developer now knows, the future of iOS app development is SwiftUI. Apple’s new UI development language is now on its 2nd major release. While my own personal feeling is that the framework is not quite ready for prime time (much like when Swift first arrived. It’s missing some fairly key features) and we are perhaps a version or 2 away from it realistically being an option for being used to build a complete app. There is no denying that it is the future and when it works well, it makes building UI a lot easier.\n\nIf you are using an advanced iOS architecture VIPER, MVVM etc it is probably the case that you have abstracted your routing or creating of your view controllers away into a separate part of your architecture. When you need to navigate or deal with a deeplink for example, you will hopefully have something like a dependency injection framework or factory to create your view controller. This is than pushed onto the navigation stack or presented by the view controller depending on what you are trying to do.\n\nThis is something that is fairly straight forward in UIKit and makes a lot of sense. In this article we are going to discuss the workings of SwiftUI and how that approach is no longer possible.\n\n\n\n\n\n\nExample\n\n// 1\nstruct ContentView: View {\n    var body: some View {\n        NavigationView(content: {\n            NavigationLink(destination: DetailView()) {\n                Text(\"Navigate\")\n            }\n        })\n        \n    } \n}\n\n// 2\nstruct DetailView: View {\n    var body: some View {\n        Text(\"Detail View\")\n    }\n}\n\nThis is a fairly simple SwiftUI example but let’s talk through it.\n\n\n  First we have a ContentView, this contains a NavigationView which is kind of similar to a UINavigationController in UIKit, however it is a lot more limited. We have a navigation link that allows the user to tap the text view and will ‘push’ the detail view on to the stack.\n  Second we have our detail view that simply displays some text.\n\n\nIf we run the code and tap on the links we should get something like this:\n\n\n\nSeems to work as intended right? What problems are there with this approach?\n\n\n  There is a tight coupling between the ContentView and the DetailView, what if we want to change the navigation destination?\n  What if we want to use the ContentView in a different app that doesn’t contain a DetailView but something else?\n  What if the DetailView has dependencies we need to inject when it’s created? How does the ContentView know what to do in order to create the DetailView?\n  What if we wish to perform an event such as fire an analytics event before moving to the next view?\n  What if we wish to present the view in a modal rather than pushing it to the navigation stack?\n\n\nMany of the more advanced architectures and frameworks have already solved these problems using a router / co-ordinator pattern. These are responsible for handling any navigation logic and often talk to a dependency injection module in order to create the destination view and pushing it onto the navigation stack or presenting it.\n\nDecoupling the Views\n\nThe first thing we can try to do is abstract away the creation of the detail view. This will at least give us the opportunity to change the destination without the knowledge of the ContentView.\n\n// 1\nfinal class ContentPresenter: ObservableObject {\n    func getDetailView() -&gt; AnyView {\n        return AnyView(DetailView())\n    }\n}\n\n// 2\nstruct ContentView: View {\n    @ObservedObject private var presenter: ContentPresenter\n    \n    init(presenter: ContentPresenter) {\n        self.presenter = presenter\n    }\n    \n    var body: some View {\n        NavigationView(content: {\n            NavigationLink(destination: presenter.getDetailView()) {\n                Text(\"Navigate\")\n            }\n        })\n        \n    }\n}\n\nstruct DetailView: View {\n    var body: some View {\n        Text(\"Detail View\")\n    }\n}\n\nSo let’s have a look at what we are doing here:\n\n\n  First of all we have tried to separate out the creation of the destination view into another object. Ideally we could put this into a protocol but for the purpose of simplicity we have just used an object.\n  We are injecting the presenter into the ContentView now, you will also notice in the NavigationLink we are now calling a method on the presenter to get the destination.\n\n\nWhat does this give us that the previous example doesn’t?\n\n\n  There is no longer tight coupling between the ContentView and the DetailView. The destination is no longer hardcoded. If we make the presenter using a protocol for example. We can inject different presenters and have different destinations.\n  If the detailview has its own dependencies that need injecting then the presenter can take care of that as well without having to code them in here.\n\n\nHowever it’s not all tea and biscuits! There are still a number of issues highlighted earlier that this solution doesn’t solve:\n\n\n  We are still not able to trigger any analytics events or any other app behaviours off the back of the navigation trigger. Block the user from navigating until they have logged in for example.\n  We can’t change or configure how the navigation happens, for example presenting a login vs actually performing navigation.\n  We are also exposing navigation to the view, a presenter typically would not need to expose navigation functionality to the view. It would handle a tap event and then hand off that navigation logic to the router. Here we have to expose that functionality to the view itself.\n\n\n\n\n\n\n\nKeep with UIKit for navigation, for now\n\nMy personal feeling is that navigation in SwiftUI could do with some more work. Views themselves should not know or care about where they are navigating to and how. They should be a visual representation of state. Of course, the navigation could be a presentation of state too, however a quick peak at the NavigationView docs shows no access to any form of state at all. The navigation view polices its own state, nothing outside of the object has a way to modify that state.\n\nFurther to that, many of the methods we have come to expect from UINavigationController are simply not available here. Whether it’s lack of maturity or a slightly confused approach I don’t know. My recommendation for now would be to make use of UINavigationControllers and the UIHostingController to perform navigation for the time being, at least until a better way to manage and manipulate the navigation state is added to SwiftUI.\n\nLet’s have a quick look at how that changes things. First we need to create a hosting controller and inject our SwiftUI view:\n\nlet presenter = ContentPresenter()\nlet vc = UIHostingController(rootView: ContentView(presenter: presenter))\nlet navigationController = UINavigationController(rootViewController: vc)\npresenter.navigationController = navigationController\n\nSo here we are creating our presenter and our view as before but adding them into a UIHostingViewController and a navigation controller. The UIHostingViewController allows us to put SwiftUI views into what is essentially a UIViewController and use it within a UIKit app.\n\nWe have also passed a reference to the navigation controller to the presenter. Let’s have a look at our updated SwiftUI code now that we have refactored it into a UIHostingController.\n\n// 1\nfinal class ContentPresenter: ObservableObject {\n    weak var navigationController: UINavigationController?\n    \n    func buttonTapped() {\n        // Do whatever we like\n        // ...\n        // Navigate\n        let vc = UIHostingController(rootView: DetailView())\n        navigationController?.pushViewController(vc, animated: true)\n    }\n}\n\n// 2\nstruct ContentView: View {\n    @ObservedObject private var presenter: ContentPresenter\n    \n    init(presenter: ContentPresenter) {\n        self.presenter = presenter\n    }\n    \n    var body: some View {\n        Button(action: { presenter.buttonTapped() }) {\n            Text(\"Navigate\")\n        }\n    }\n}\n\nWhat’s changed here:\n\n\n  First of all our presenter has replaced our getDetailView with a more generic button tapped function. This function can do any number of things we need it to do, before finally navigating. Here you can see we are using our reference to the navigation controller to push the new view controller.\n  In our SwiftUI view you will see we no longer have a NavigationView or a NavigationLink. Our view has become far more generic and doesn’t contain and navigation specific logic. You will also see that we have a button which has a tap action assigned by the presenter. This allows us to make the button do anything, not just trigger navigation.\n\n\nHopefully you found this helpful when exploring navigation options in SwiftUI. You can find the SwiftUI Sample and the UIHostingController samples on github.\n\n\n\n\n\n",
      tags: ["swift","combine","swiftui"],
      id: 16
    });
    

    index.add({
      title: "Using protocols, ObservableObject and @Published property wrappers in SwiftUI",
      category: ["swiftUI"],
      content: "Background\n\nAs I’m sure any iOS developer now knows, the future of iOS app development is SwiftUI. Apple’s new UI development language is now on it’s 2nd major release. While my own personal feeling is that the framework is not quite ready for prime time (much like when Swift first arrived. It’s missing some fairly key features) and we are perhaps a version or 2 away from it realistically being an option for being used to build a complete app. There is no denying that it is the future and when it works well, it makes building UI a lot easier.\n\nAs SwiftUI is the future, I’ve been investigating how teams might migrate their existing architectures across to the new technology. There a number of challenges presented by migrating to SwiftUI we will discuss below. As the title suggests we will be exploring how to use a presenter to control a SwiftUI view. It doesn’t matter which architecture you are using as such, whether it’s VIPER, MVVVM, VIP, MVP etc. As long as the logic and state of the view has been abstracted away from the view itself so it can be properly unit tested.\n\n\n\n\n\n\nExample\n\nList Item View\n\nLet’s start by creating an example in SwiftUI. We will create a simple list view to display some news for example. Let’s create a simple list view first of all:\n\n// 1\nstruct ListItemViewModel: Identifiable {\n    let id: Int\n    let title: String\n    let subTitle: String?\n    let image: String\n}\n\n// 2\nstruct ListItemView: View {\n    let viewModel: ListItemViewModel\n    \n    var body: some View {\n        HStack() {\n            Image(viewModel.image)\n            VStack(alignment: .leading) {\n                Text(viewModel.title)\n                    .font(.headline)\n                viewModel.subTitle.map({\n                    Text($0)\n                        .font(.subheadline)\n                })\n            }\n        }\n    }\n}\n\n// 3\nstruct ListItemView_Previews: PreviewProvider {\n    static var previews: some View {\n        ListItemView(\n            viewModel: ListItemViewModel(\n                id: 1,\n                title: \"Test Title\",\n                subTitle: \"Test Subtitle\",\n                image: \"first\"\n            )\n        )\n    }\n}\n\nThis is quite a straight forward view, but let’s step through it.\n\n\n  First of all we define our model for the view. We have an id so that we can conform to Identifiable. This allows SwiftUI to uniquely identify each model in the view and helps with performing things like animation and reordering. We also have a title, optional subTitle and an image string. Hopefully nothing here is too scary.\n  Now we define the view inself. Views in SwiftUI are simple structs that conform to the View protocol, rather than subclasses of UIView like they used to be in UIKit. Its a simple Hstack with an image view then 2 labels stacked on top of each other. See the screen grab below.\n  Finally we have the preview code to inject an example model to use in the preview.\n\n\n\n\n\n\n\n\n\nList View\n\nNow that we have the items in our list, lets create a simple list view that displays those items.\n\n// 1\nstruct ContentView: View {\n    let listItems: [ListItemViewModel]\n \n    var body: some View {\n        List(listItems) { item in\n            ListItemView(viewModel: item)\n        }\n    }\n}\n\n// 2\nstruct ContentView_Previews: PreviewProvider {\n    static var previews: some View {\n        let items = [ListItemViewModel(id: 1, title: \"test\", subTitle: \"test sub\", image: \"first\"),\n                    ListItemViewModel(id: 2, title: \"test2\", subTitle: \"test sub1\", image: \"first\"),\n                    ListItemViewModel(id: 3, title: \"test3\", subTitle: \"test sub2\", image: \"first\"),\n                    ListItemViewModel(id: 4, title: \"test4\", subTitle: \"test sub3\", image: \"first\"),\n                    ListItemViewModel(id: 5, title: \"test5\", subTitle: \"test sub4\", image: \"first\")]\n        \n        ContentView(listItems: items)\n    }\n}\n\nOk so what do we have here:\n\n\n  A simple ContentView who has an array of list item view models and a body. The body lists out the content of our list using the ListItemView we created earlier. Simple\n  Here we have some test data to show that our list is working. If we preview this view we will see something like this:\n\n\n\n\nThat’s wonderful, however it is not particularly dynamic. This is where a presenter or view model would come in. If we look at the description of MVP or MVVM we will see they have a similar role:\n\n\n  The presenter acts upon the model and the view. It retrieves data from repositories (the model), and formats it for display in the view.\n\n\nThere are further abstractions layers (such as interactors and use cases). However we are less concerned with them in this discussion and more on the relationship between the view and the presenter who is holding the state and logic of the view.\n\nAbstracting the state\n\n\n\n\n\n\nSo at the moment we have a pretty stateless SwiftUI view that simply displays a hardcoded list. Now let’s attempt to abstract the list items away into another object that is injected into the view. This object would be responsible for fetching our items and loading them for the view.\n\nThis is where an ObservableObject comes in.\n\n\n  When your type conforms to ObservableObject, you are creating a new source of truth and teaching SwiftUI how to react to changes. In other words, you are defining the data that a view needs to render its UI and perform its logic. SwiftUI uses this dependency to automatically keep your view consistent and show the correct representation of your data. We like to think of ObservableObject as your data dependency surface. This is the part of your model that exposes data to your view, but it’s not necessarily the full model.\n\n\nSo lets update our example to move our list of items into a separate class that conforms to this protocol.\n\nfinal class ListPresenter: ObservableObject {\n    @Published var listItems: [ListItemViewModel] = []\n}\n\n\nstruct ContentView: View {\n    @ObservedObject private var presenter: ListPresenter\n    \n    init(presenter: ListPresenter) {\n        self.presenter = presenter\n    }\n \n    var body: some View {\n        List(presenter.listItems) { item in\n            ListItemView(viewModel: item)\n        }\n    }\n}\n\nThe @Published property wrapper here works with the ObservableObject to notify SwiftUI whenever the value changes in order to trigger an update.\n\nWe also see the @ObservedObject property wrapper. This causes this view to subscribe to the ObservableObject that’s assigned to it, and invalidates the view any time the object updates.\n\nThis is great and allows us to inject an object from outside of the view who can manage the fetching and supplying to the view, whenever the listItems var updates, the view will automatically update!\n\nDe-coupling dependencies\n\nNow there is one problem here, can you see it? This view has a dependency between the view itself and the presenter class. Now if you are following the SOLID principles for example, and like to separate dependencies between your classes and layers we will need to remove the dependency between the view and presenter.\n\nTo do this lets change the ListPresenter class to be a protocol instead:\n\nfinal class ListPresenterImp: ListPresenter {\n    @Published var listItems: [ListItemViewModel] = []\n}\n\nprotocol ListPresenter: ObservableObject {\n    @Published var listItems: [ListItemViewModel] { get }\n}\n\nstruct ContentView: View {\n    @ObservedObject private var presenter: ListPresenter\n    \n    init(presenter: ListPresenter) {\n        self.presenter = presenter\n    }\n \n    var body: some View {\n        List(presenter.listItems) { item in\n            ListItemView(viewModel: item)\n        }\n    }\n}\n\nThis looks like it should be a straight forward change… Wrong! You will now start seeing errors galore. The primary cause coming from the decleration of our new protocol:\n\n\n  Property ‘listItems’ declared inside a protocol cannot have a wrapper\n\n\nThe problem here being exactly as the error states. We cannot use property wrappers inside protocols! That is going to cause a bit of a problem as we now can’t make use of the nice integration with SwiftUI via @Published properties, or so it seems…\n\nLet’s take a step back for a moment, what exactly does the @Published property wrapper actually do? The @Published property wrapper essentially provides a publisher that the SwiftUI system can subscribe to in order to listen to updates to the value. This is in fact an implementation detail. One of the key points of protocol oriented programming is to abstract the implementation of functions are variables away from the dependency so that it is unaware of the inner workings. By trying to apply a property wrapper to the protocol we are trying to enforce how that variable should implemented under the hood. When infact should the implementing class of our protocol wish to, they could create their own custom implementation of the wrapper.\n\nFixing the errors\n\nOk so let’s start by removing the @Published property wrapper from our protocol:\n\nfinal class ListPresenterImp: ListPresenter {\n    @Published var listItems: [ListItemViewModel] = []\n}\n\nprotocol ListPresenter: ObservableObject {\n    var listItems: [ListItemViewModel] { get }\n}\n\nstruct ContentView: View {\n    @ObservedObject private var presenter: ListPresenter\n    \n    init(presenter: ListPresenter) {\n        self.presenter = presenter\n    }\n \n    var body: some View {\n        List(presenter.listItems) { item in\n            ListItemView(viewModel: item)\n        }\n    }\n}\n\nGreat! However there are now a bunch of different errors occuring… The key one that we need to pay attention to is this one:\n\n\n  Protocol ‘ListPresenter’ can only be used as a generic constraint because it has Self or associated type requirements\n\n\nRight, so we have solved the riddle of @Published but this has now surfaced another problem. In order for our ListPresenter protocol to be compatible with the ObervedObject property wrapper in the view, it must extend ObservableObject. Now the problem here is that the ObservableObject uses an associatedtype. Which means if we wish to use it or hold a reference to it we must do type erasure (for more info read my previous post on type erasure) or use a generic constraint.\n\nThe simplest solution is for us to use a generic constraint on the view. View the code below:\n\nfinal class ListPresenterImp: ListPresenter {\n    @Published var listItems: [ListItemViewModel] = []\n}\n\nprotocol ListPresenter: ObservableObject {\n    var listItems: [ListItemViewModel] { get }\n}\n\nstruct ContentView&lt;T&gt;: View where T: ListPresenter {\n    @ObservedObject private var presenter: T\n    \n    init(presenter: T) {\n        self.presenter = presenter\n    }\n \n    var body: some View {\n        List(presenter.listItems) { item in\n            ListItemView(viewModel: item)\n        }\n    }\n}\n\nSo what has changed here. You will now notice that we have added a generic type T to our view. We have also added a generic constraint when implementing the View protocol which signals that the init and body implementations here are only when type T is a ListPresenter. Now in this instance that works fine as we only intend to use this view with our ListPresenter class. This removes the errors and the code now compiles. Let’s update the code and run a little test to make sure we are still getting all the reactive goodness of SwiftUI.\n\nfinal class ListPresenterImp: ListPresenter {\n    @Published var listItems: [ListItemViewModel] = []\n    \n    init() {\n        Timer.scheduledTimer(withTimeInterval: 5.0, repeats: false) { (timer) in\n            let items = [ListItemViewModel(id: 1, title: \"test\", subTitle: \"test sub\", image: \"first\"),\n                        ListItemViewModel(id: 2, title: \"test2\", subTitle: \"test sub1\", image: \"first\")]\n            \n            self.listItems = items\n        }\n    }\n}\n\nprotocol ListPresenter: ObservableObject {\n    var listItems: [ListItemViewModel] { get }\n}\n\nstruct ContentView&lt;T&gt;: View where T: ListPresenter {\n    @ObservedObject private var presenter: T\n    \n    init(presenter: T) {\n        self.presenter = presenter\n    }\n \n    var body: some View {\n        List(presenter.listItems) { item in\n            ListItemView(viewModel: item)\n        }\n    }\n}\n\nWe have updated our list presenter implementation class to update our list items after 5 seconds. Nice and easy. If we initialise our view with a presenter with 5 items as below, then after 5 seconds our list should reduce to the 2 items as set in the timer.\n\nlet items = [ListItemViewModel(id: 1, title: \"test\", subTitle: \"test sub\", image: \"first\"),\n                    ListItemViewModel(id: 2, title: \"test2\", subTitle: \"test sub1\", image: \"first\"),\n                    ListItemViewModel(id: 3, title: \"test3\", subTitle: \"test sub2\", image: \"first\"),\n                    ListItemViewModel(id: 4, title: \"test4\", subTitle: \"test sub3\", image: \"first\"),\n                    ListItemViewModel(id: 5, title: \"test5\", subTitle: \"test sub4\", image: \"first\")]\n        \nlet presenter = ListPresenterImp()\npresenter.listItems = items\nlet contentView = ContentView(presenter: presenter)\n\n\n\n\n\n\nNow let’s run this as part of an app and see what happens:\n\n\n\nSo as you can see, after 5 seconds the list of items is reduced after 5 seconds to 2 items, proving that our implementation works and we are still able to hook into the nice secret sauce that combine and swiftUI expose to us to allow us to update our views. I’ve seen some rather crazy implementations and workarounds on Stack Overflow. Hopefully this implementation is a little nicer!\n\nDownload the sample project to run it for yourself (Xcode 12.4)\n",
      tags: ["swift","combine","swiftui","architecture"],
      id: 17
    });
    

    index.add({
      title: "Repository Pattern in Swift",
      category: ["architecture"],
      content: "Background\n\nAll apps developed require data of some description. This data is stored somewhere, could be on the device itself, in a remote database/service or a combination. Let’s take a look at the most common sources of data:\n\n\n  JSON web services\n  UserDefaults\n  Core Data\n  Realm\n  Other 3rd party system\n\n\nEach of these methods saves data in a different format. Now I’m sure you will have used at least one of these methods in your apps at some point to retrieve / save data.\n\nWhen not using the repository pattern it is quite common to access and use these elements directly, either in your ViewController or in some other part of your app depending how it is structured.\n\n\n\n\n\n\nThe problem\n\nWhat’s the problem with this approach? Your app becomes difficult to maintain. Now if you only have a small app with a few screens then this isn’t much of a problem as there are only a few elements to change.\n\nHowever, what if you are working on a large app with several developers and lots of code? You could have NSManagedObjects or Codable objects littered throughout the codebase for example. What happens if you wish to remove Core Data? Perhaps move to realm? You would need to modify all of the classes in your codebase where you had used your Core Data objects.\n\nSimilarly, if you are using Codable objects directly from your JSON response. What happens when your backend team changes the API or you switch to a different API provider? The structure of the data may change which means your Codable objects might change. Again you will need to modify a large number of classes if you are working on a large app.\n\nWe can also apply this to the other options such as accessing data from 3rd party frameworks. If we use the objects returned from the framework directly, they will all need changing if we change provider or the SDK changes.\n\nThere is also the question of query language. Web services use headers and URLQueryItem, Core Data uses Predicates and so on. Every entry point to query the data must know and understand the underlying query language in order to get the information it once. Again, if this changes we need change every query point to the new format.\n\nLet’s have a look at the diagram below:\n\n\n\nHere we have an app structure that is making use of Core Data. There is an object that is being used to access the stack that returns some data. Let’s say for this example that it is news articles. These new articles must inherit from NSManagedObject to be used in Core Data. Now if our data layer is returning NSManagedObjects to the rest of our app structure we now have a dependency between Core Data and the rest of the files in our app. If we wish to move to Realm for example, or switch to using some other form of data store we would need to modify all the of files in the app. The app in this example is only small, imagine having to do that for a much bigger app!\n\nDomain Objects and the Repository\n\nThis is where Domain Objects come in. Domain Objects are value objects that are defined by your application. Rather than using objects and structures defined outside of the app, we define what we want the objects to look like. It’s then up to the repository to map between the data storage object / structure to these value objects.\n\nWhen we do this, it means any changes to the data access layer, as we discussed earlier such as data structure changes or changes in provider don’t impact the rest of the app. The only part of the app that needs to be updated is the repository and it’s mapping to the domain objects.\n\nThe below quote summarises the idea of the pattern:\n\n\n  Repositories are classes or components that encapsulate the logic required to access data sources. They centralize common data access functionality, providing better maintainability and decoupling the infrastructure or technology used to access databases from the domain model layer.\n\n\nLet’s have a look at our previous example but modified to use the a repository and domain objects:\n\n\n\nSo what is the difference here? As you can see the Core Data stack is still returning NSManagedObjects, however the repository is converting that to a domain object. This object doesn’t inherit from NSManagedObject, also it’s structure and attributes are defined by the app rather than what is in the data store.\n\nNow if we wanted to move away from Core Data to something else the only classes that need to be changed are the Core Data stack and the repository. The rest of the app does not need to be changed as we can map the new data stores type to our domain objects using the repository.\n\n\n\n\n\n\nExample\n\nTo show a small working example we are going to use a couple of Free Public APIs (highly recommend this resource if you are looking to build a demo app or experiment). We will use 2 APIs that returns users. However they return them in a different format.\n\nhttps://jsonplaceholder.typicode.com/users/1\n\nhttps://randomuser.me/api/\n\nAs we have done in previous blog posts we are going to use QuickType to generate our Codable objects from our JSON response. We will start with our first request.\n\n// MARK: - User\nstruct User: Codable {\n    let id: Int\n    let name, username, email: String\n    let address: Address\n    let phone, website: String\n    let company: Company\n}\n\n// MARK: - Address\nstruct Address: Codable {\n    let street, suite, city, zipcode: String\n    let geo: Geo\n}\n\n// MARK: - Geo\nstruct Geo: Codable {\n    let lat, lng: String\n}\n\n// MARK: - Company\nstruct Company: Codable {\n    let name, catchPhrase, bs: String\n}\n\nThis structure will allow us to decode the response from the first request. Let’s make a simple example that takes the response and outputs some data. We will be using code from our Simple JSON Decoder to process the output so feel free to read up if the code you see doesn’t make sense.\n\nlet url = URL(string: \"https://jsonplaceholder.typicode.com/users/1\")!\n// 1\nlet task = URLSession.shared.dataTask(with: url, completionHandler: { (user: User?, response, error) in\n\t// 2\n    if let error = error {\n        print(error.localizedDescription)\n        return\n    }\n\n    // 3\n    if let user = user {\n        print(user.name)\n        print(user.address.street)\n        print(user.address.city)\n        print(user.address.zipcode)\n        print(user.address.geo.lat)\n        print(user.address.geo.lng)\n    }\n})\ntask.resume()\n\nSo let’s step through what’s happening here:\n\n\n  First of all we are making the request using our Simple JSON Decoder to return our new User type.\n  Output any errors\n  So here we are outputting the name, address and location of the user we get back. Super simple right now.\n\n\n\n\n\n\n\nManaging change\n\nNow let’s say we change provider. Maybe our backend team changes the API, or we switch data provider or from 2 different data provider SDKs. In our example we will switch from the first url (https://jsonplaceholder.typicode.com/users/1) to the second (https://randomuser.me/api/).\n\nThe first thing we will need to do is change all of our codable objects as the structure of the response is different. Let’s use QuickType again to give us the new structure:\n\n// MARK: - Users\nstruct Users: Codable {\n    let results: [Result]\n    let info: Info\n}\n\n// MARK: - Info\nstruct Info: Codable {\n    let seed: String\n    let results, page: Int\n    let version: String\n}\n\n// MARK: - Result\nstruct Result: Codable {\n    let gender: String\n    let name: Name\n    let location: Location\n    let email: String\n    let login: Login\n    let dob, registered: Dob\n    let phone, cell: String\n    let id: ID\n    let picture: Picture\n    let nat: String\n}\n\n// MARK: - Dob\nstruct Dob: Codable {\n    let date: String\n    let age: Int\n}\n\n// MARK: - ID\nstruct ID: Codable {\n    let name: String\n    let value: String?\n}\n\n// MARK: - Location\nstruct Location: Codable {\n    let street: Street\n    let city, state, country: String\n    let postcode: Int\n    let coordinates: Coordinates\n    let timezone: Timezone\n}\n\n// MARK: - Coordinates\nstruct Coordinates: Codable {\n    let latitude, longitude: String\n}\n\n// MARK: - Street\nstruct Street: Codable {\n    let number: Int\n    let name: String\n}\n\n// MARK: - Timezone\nstruct Timezone: Codable {\n    let offset, timezoneDescription: String\n\n    enum CodingKeys: String, CodingKey {\n        case offset\n        case timezoneDescription = \"description\"\n    }\n}\n\n// MARK: - Login\nstruct Login: Codable {\n    let uuid, username, password, salt: String\n    let md5, sha1, sha256: String\n}\n\n// MARK: - Name\nstruct Name: Codable {\n    let title, first, last: String\n}\n\n// MARK: - Picture\nstruct Picture: Codable {\n    let large, medium, thumbnail: String\n}\n\nNow this is more complicated that it needs to be for our example but I’m leaving it here as an extreme example of how different things can be. As you can probably tell the structure and types have change dramatically from our first example. So let’s try and output the same data from this example in our previous example. We can ignore the request part and just focus on the data output so we can see the differences:\n\n// Request 1 output\nif let user = user {\n    print(user.name)\n    print(user.address.street)\n    print(user.address.city)\n    print(user.address.zipcode)\n    print(user.address.geo.lat)\n    print(user.address.geo.lng)\n}\n\n\n// Request 2 output\nif let user = users?.results.first {\n    print(\"\\(user.name.first) \\(user.name.last)\")\n    print(user.location.street.name)\n    print(user.location.city)\n    print(user.location.postcode)\n    print(user.location.coordinates.latitude)\n    print(user.location.coordinates.longitude)\n}\n\nAs you can see from even this simple example. We would have to change 7 lines of code, just to produce the same output. Now imagine this change happening on a much bigger project! There could possibly be 100s of lines of code that would need updating, all because the API response has changed.\n\nRepository Pattern\n\n\n\n\n\n\nHere is where the repository pattern comes in. We can create a user repository that fetches the user and converts it to our domain object. That way we don’t need to update the output.\n\nFirst thing to do is design our domain object that will represent a User in our system. Now all we are doing in this simple example is outputting a few attributes so let’s design our object with just those attributes as we don’t need the rest.\n\nstruct DomainUser {\n    let name: String\n    let street: String\n    let city: String\n    let postcode: String\n    let latitude: String\n    let longitude: String\n}\n\nHere we have a nice simple representation of our User object. There is no need to consider any of the other possible attributes returned from the API. We aren’t using them in our application and they will just sit around taking up valuable memory. You will also notice that this object doesn’t conform to Codable or subclass NSManagedObject. This is because DomainObject should not contain any knowledge about how they are stored. That is the responsibility of the repository.\n\nTo design our repository we can make use of Generics and Protocols to design a repository we can use for anything, not just our DomainUser. Let take a look:\n\nprotocol Repository {\n    associatedtype T\n    \n    func get(id: Int, completionHandler: (T?, Error?) -&gt; Void)\n    func list(completionHandler: ([T]?, Error?) -&gt; Void)\n    func add(_ item: T, completionHandler: (Error?) -&gt; Void)\n    func delete(_ item: T, completionHandler: (Error?) -&gt; Void)\n    func edit(_ item: T, completionHandler: (Error?) -&gt; Void)\n}\n\nprotocol CombineRepository {\n    associatedtype T\n    \n    func get(id: Int) -&gt; AnyPublisher&lt;T, Error&gt;\n    func list() -&gt; AnyPublisher&lt;[T], Error&gt;\n    func add(_ item: T) -&gt; AnyPublisher&lt;Void, Error&gt;\n    func delete(_ item: T) -&gt; AnyPublisher&lt;Void, Error&gt;\n    func edit(_ item: T) -&gt; AnyPublisher&lt;Void, Error&gt;\n}\n\nHere we have different functions for all of the operations we can do. What you will notice is that none of these functions specify where or how the data is stored. Remember when we talked about different storage options at the beginning? We could implement a repo that talks to an API (like in our example), one that stores things in Core Data or one that writes to UserDefaults. It’s up to the repository that implements the protocol to decide these details, all we care about is that we can load and save the data from somewhere.\n\nSee it action\n\nNow we have defined what the repository pattern is, let’s create 2 implementations. One for our first request and one for the second. Both should return domain objects, rather than the type returned from the request.\n\n// 1\nenum RepositoryError: Error {\n    case notFound\n}\n\nstruct FirstRequestImp: Repository {\n    typealias T = DomainUser\n    \n    // 2\n    func get(id: Int, completionHandler: @escaping (DomainUser?, Error?) -&gt; Void) {\n        let url = URL(string: \"https://jsonplaceholder.typicode.com/users/1\")!\n        let task = URLSession.shared.dataTask(with: url, completionHandler: { (user: User?, response, error) in\n            if let error = error {\n                completionHandler(nil, error)\n                return\n            }\n\n            guard let user = user else {\n                completionHandler(nil, RepositoryError.notFound)\n                return\n            }\n            \n            // 3\n            let domainUser = DomainUser(\n                name: user.name,\n                street: user.address.street,\n                city: user.address.city,\n                postcode: user.address.zipcode,\n                latitude: user.address.geo.lat,\n                longitude: user.address.geo.lng\n            )\n            \n            completionHandler(domainUser, nil)\n        })\n        task.resume()\n    }\n    \n     // 4\n    func list(completionHandler: @escaping ([DomainUser]?, Error?) -&gt; Void) {}\n    func add(_ item: DomainUser, completionHandler: @escaping (Error?) -&gt; Void) {}\n    func delete(_ item: DomainUser, completionHandler: @escaping (Error?) -&gt; Void) {}\n    func edit(_ item: DomainUser, completionHandler: @escaping (Error?) -&gt; Void) {}\n}\n\nstruct SecondRequestImp: Repository {\n    typealias T = DomainUser\n    \n    func get(id: Int, completionHandler: @escaping (DomainUser?, Error?) -&gt; Void) {\n        let url = URL(string: \"https://randomuser.me/api/\")!\n        let task = URLSession.shared.dataTask(with: url, completionHandler: { (users: Users?, response, error) in\n            if let error = error {\n                completionHandler(nil, error)\n                return\n            }\n\n            guard let user = users?.results.first else {\n                completionHandler(nil, RepositoryError.notFound)\n                return\n            }\n            \n            // 5\n            let domainUser = DomainUser(\n                name: \"\\(user.name.first) \\(user.name.last)\",\n                street: user.location.street.name,\n                city: user.location.city,\n                postcode: \"\\(user.location.postcode)\",\n                latitude: user.location.coordinates.latitude,\n                longitude: user.location.coordinates.longitude\n            )\n            \n            completionHandler(domainUser, nil)\n        })\n        task.resume()\n    }\n    \n    func list(completionHandler: @escaping ([DomainUser]?, Error?) -&gt; Void) {}\n    func add(_ item: DomainUser, completionHandler: @escaping (Error?) -&gt; Void) {}\n    func delete(_ item: DomainUser, completionHandler: @escaping (Error?) -&gt; Void) {}\n    func edit(_ item: DomainUser, completionHandler: @escaping (Error?) -&gt; Void) {}\n}\n\n\n\n\n\n\nThere’s quite a bit of code here so let’s step through it.\n\n\n  First of all we have defined a new error to send back if we don’t receive any user info from the API.\n  This is the same call we made in our example before.\n  Now here we are taking the returned Codable User and converting it to your new DomainUser class.\n  We aren’t implementing the other functions in this example so just leaving them empty for now to remove errors.\n  This struct is the second request we are making, and again here we are mapping our Users Codable type from the second request to our DomainUser.\n\n\nNow that we have made our two repositories, let’s show how we can quickly switch between them without breaking / changing code.\n\nlet repository: FirstRequestImp = FirstRequestImp()\nrepository.get(id: 1) { (user, error) in\n    if let error = error {\n        print(error)\n    }\n    \n    if let user = user {\n        print(user.name)\n        print(user.street)\n        print(user.city)\n        print(user.postcode)\n        print(user.latitude)\n        print(user.longitude)\n    }\n}\n\nHere is our example from earlier in the article but updated to use our new repositories. Here we go and fetch the user and print their details, the same as before. Now below we can switch to our second request and see how that will work.\n\nlet repository: SecondRequestImp = SecondRequestImp()\nrepository.get(id: 1) { (user, error) in\n    if let error = error {\n        print(error)\n    }\n    \n    if let user = user {\n        print(user.name)\n        print(user.street)\n        print(user.city)\n        print(user.postcode)\n        print(user.latitude)\n        print(user.longitude)\n    }\n}\n\nNow notice how the only part we changed was the implementation class? The rest of the code remained the same even though where the data was coming from has changed and is coming back in a completely different structure. Now imagine we are using this repo in many places to fetch user details. We can quickly switch between different data sources without changing the code that uses it. The only changes we have to make are to the repo and to the data mapping code. So only one change rather than a change in every single class that uses these objects.\n\nConclusion\n\nSo let’s recap what we have discussed here:\n\n\n  First of all we discussed the problem of using data storage classes throughout your codebase. Especially on large projects if you need to switch data source / structure.\n  We then discussed how using the repository pattern and mapping to domain objects rather than using data storage classes can make your code easier to change in the future.\n  We worked through some examples of how changing API structures can impact your code.\n  We then implemented a basic repository pattern with mapping to domain objects to show how doing this can make updating your project easier.\n\n\nFinally let’s discuss the pros and cons of the approach:\n\nAdvantages\n\n\n  Code is easier to change if you need to switch data source or structure\n  Separates concerns of where / how data is stored away from the rest of your app\n\n\nDisadvantages\n\n\n  Adds more code and complexity\n  Need to write mappers for each object to domain objects\n  Not really needed on smaller solo projects\n\n\nFeel free to download the playground and play around with the examples yourself\n\n\n\n\n\n",
      tags: ["swift","combine","generics","architecture"],
      id: 18
    });
    

    index.add({
      title: "Simple offline caching in Swift and Combine",
      category: ["networking"],
      content: "Background\n\nFollowing on from the previous post where we explored simple JSON decoding. In this post we are going to extend that simple networking example to include some offline caching so that if our network requests fail we can still provide content.\n\nI hear of a lot of people put off by providing a caching layer in their apps for data. Popular solutions include putting an actual relational database inside your app to cache the data such as using Core Data or Realm. Now these solutions are fine if you are intending to levarage the power of a relational database to perform some kind of task. However they add a lot more complexity if you are simply using them as a caching layer. A few draw backs below:\n\n\n  If you are consuming in an house API you may be trying to replicate a back end database structure driven by a much more capable server side DBMS.\n  Whether you are mapping against a back end database or just the returned JSON. What happens when the structure changes? Do you need to update your parsing and data structure. Do you need to migrate data?\n  Not only do you need to make sure you can parse and store the data correctly, you then must make sure you query the data in the same way so that you get the same results as returned from the API.\n  What happens if multiple requests need to update the data? Handling concurrent data updates carries it’s own complexity and head aches.\n\n\nThis is just a sample of the challenges faced when trying to use a relational database as a caching layer for your app. Now you could build some custom caching layer that writes things to disk or a library such as PINCache. However what if I told you there is something simpler that is already built in to iOS as standard?\n\n\n\n\n\n\nCaching Headers\n\nTo help explain this we need to explore how HTTP caching headers are intended to work. Now, most request to an API will return a bunch of HTTP headers. These provide information and advice to the receiver about the response to the request. We won’t cover them all but the one we are most interested in for this example is the Cache-Control header.\n\n\n  Cache-control is an HTTP header used to specify browser caching policies in both client requests and server responses. Policies include how a resource is cached, where it’s cached and its maximum age before expiring (i.e., time to live)\n\n\nThe part of this statement that talks about maximum age before expiring is what we will explore here. Most APIs will specify something called a max-age in the response headers. This is the length of time in seconds that the receiver should consider this information valid for. After that period of time the response should be considered stale and new data be fetched from the source.\n\nBy default URLSession and URLRequest have a cache policy of useProtocolCachePolicy. This means they will honour the HTTP caching headers when making requests. In the case of the above it will cache request responses for the time specified in the header. It is possible to override this behaviour if you wish using one of the other options.\n\nPostman\n\nTo demonstrate this behaviour in action we are going to use a tool called Postman. You may be using this already, it’s a fantastic tool for developing and testing APIs. One of the services that are provided by Postman is something called Postman Echo. This is a service that allows you to send various URL parameters to it and have postman reply those items back to you in a certain response format. To test our example we are going to use the response headers service that is provided, this allows us to specify headers and values in the url query string and have them played back to us in the actual response headers.\n\nIf we hit the URL below, you will get a response with the specified headers that you send in the URL query params.\n\nhttps://postman-echo.com/response-headers?Cache-Control=max-age=30\n\nWe get back a header in the response of Cache-Control: max-age=30. This means that anyone processing the response should cache the response for 30 seconds at the most before requesting fresh data, as discussed previously.\n\nWe can use this to prove how the caching works in URLSession.\n\nCaching in URLSession\n\nLet’s setup an example below on how to test out these cache headers:\n\n// 1\nlet url = URL(string: \"https://postman-echo.com/response-headers?Content-Type=text/html&amp;Cache-Control=max-age=30\")!\nlet request = URLRequest(url: url)\n\nlet task = URLSession.shared.dataTask(with: url) { (data, response, error) in\n\t// 2\n    if let httpResponse = response as? HTTPURLResponse,\n        let date = httpResponse.value(forHTTPHeaderField: \"Date\"),\n        let cacheControl = httpResponse.value(forHTTPHeaderField: \"Cache-Control\") {\n\n        // 3\n        print(\"Request1 date: \\(date)\")\n        print(\"Request1 Cache Header: \\(cacheControl)\")\n    }\n}\ntask.resume()\n\n// 4\nsleep(5)\n\n// 5\nlet task2 = URLSession.shared.dataTask(with: url) { (data , response, error) in\n    if let httpResponse = response as? HTTPURLResponse,\n        let date = httpResponse.value(forHTTPHeaderField: \"Date\"),\n        let cacheControl = httpResponse.value(forHTTPHeaderField: \"Cache-Control\") {\n\n        print(\"Request2 date: \\(date)\")\n        print(\"Request2 Cache Header: \\(cacheControl)\")\n    }\n}\ntask2.resume()\n\nLet’s step through this example step by step to demonstrate what is happening:\n\n\n  First of all we setup our postman echo request, we will set this up to return cache headers of 30 seconds\n  We make a request using the standard dataTask method. When we get the response we cast it to an HTTPURLResponse. An HTTPURLResponse contains a dictionary called allHeaders which is a dictionary containing all of the headers returned in the response. However this is error prone as dictionary keys are case sensitive. To combat this Apple have added a new function called value that takes a key string but does a case-insensitive match against the header so you don’t have to.\n  With the code in point 2 we are grabbing the date of the response and the cache control header and printing them to the console so we can see what they are.\n  We sleep for 5 seconds then perform another request.\n  Here are performing the same request as above and fetching the values of the response headers again. This will help us to see how the caching works.\n\n\nIf we run the above code in our playground we should see the following in the console:\n\nRequest1 date: Tue, 23 Jun 2020 09:21:36 GMT\nRequest1 Cache Header: max-age=30\nRequest2 date: Tue, 23 Jun 2020 09:21:36 GMT\nRequest2 Cache Header: max-age=30\n\n\nSo what does this tell us about our requests?\n\n\n  The first 2 lines show that our request executed at a certain date and time, the second line displays the cache header we configured in our postman echo request.\n  The last 2 lines show the same thing?\n\n\nThis is because we set a cache time of 30 seconds in the request header. As you know from step 4 above, we slept for 5 seconds inbetween each request. The fact the date headers are the same shows that the second request response is in fact the same response as the first request, it has just been fetched from the cache.\n\nTo prove this we can modify the request so that we only cache the response for 3 seconds, this way when we sleep for 5 seconds, the response from the first request should be considered stale and the second request should end up with a new response.\n\nLet’s modify the URL in our request to set the cache control to 3:\n\nhttps://postman-echo.com/response-headers?Cache-Control=max-age=3\n\nNow if we run the example above the console messages should look something like this:\n\nRequest1 date: Tue, 23 Jun 2020 11:34:58 GMT\nRequest1 Cache Header: max-age=3\nRequest2 date: Tue, 23 Jun 2020 11:35:03 GMT\nRequest2 Cache Header: max-age=3\n\n\nHow is this different from above. The main difference you will notice is that the request times are now different. The second request timestamp is 5 seconds after the first. This is because our cache time is 3 seconds now, so the second request is no longer pulling from the cache and is in fact a new request with a new response.\n\n\n\n\n\n\nOffline and the Network Conditioner\n\nNow you are probably asking yourself what this has to do with offline caching? To understand how we can leverage this caching behaviour we need to throttle our requests so that they fail. One of the tools at our disposal is something called the Network Conditioner. This is provided by Apple in the additional tools download.\n\nIf you download the tools and install the network conditioner preference pane, you should be able to launch it from your Mac preferences. Once open you should see something like the below:\n\n\n\nThis tool allows you to create various network conditions on your mac, such as 100% packet loss, 3G, dial up etc. We are going to use this to replicate a connection failure in our example to see how we can begin to use some of URLSession’s properties to access cached request data.\n\nIf we add the below into our second request callback so we can see if the request errors:\n\nif let error = error {\n    print(error.localizedDescription)\n}\n\nIf we run the sample again, however this time once we receive the first 2 console messages. We activate the network conditioner using 100% loss. This will cause the second request to fail (it may take a few seconds for the request to timeout).\n\nIf done correctly we should see something like below in the console:\n\nRequest1 date: Tue, 23 Jun 2020 12:36:09 GMT\nRequest1 Cache Header: max-age=3\nThe request timed out.\n\n\nNow we aren’t getting a response from the second request. Instead we are receiving an error. This is expected behaviour as the second request is indeed failing. What we can do in this scenario is grab the response from the cache if we so wish. To do so add the code below to the second completion handler:\n\nif let cachedResponse = URLSession.shared.configuration.urlCache?.cachedResponse(for: request),\n    let httpResponse = cachedResponse.response as? HTTPURLResponse,\n    let date = httpResponse.value(forHTTPHeaderField: \"Date\") {\n\n    print(\"cached: \\(date)\")\n}\n\nPart of the URLSession is the URLSessionConfiguration. This is an object which provides all of the configuration for the URLSession. One of the attributes here is the URLCache. This is where the magic happens. It is an in-memory and on-disk cache of the responses from URLRequests. It is responsible for storing and deleting the data, in our example that is controlled via the response headers.\n\nOne of the methods on the URLCache is cachedResponse. This will return the cached response for any URL request still in the cache.\n\nIn the example above we are pulling the cached response and outputting the header of the attached HTTPURLResponse. If we take another look at our example with the additional 2 snippets above we should have something like below:\n\nlet url = URL(string: \"https://postman-echo.com/response-headers?Content-Type=text/html&amp;Cache-Control=max-age=3\")!\nlet request = URLRequest(url: url)\nlet task = URLSession.shared.dataTask(with: url) { (data, response, error) in\n    if let httpResponse = response as? HTTPURLResponse,\n        let date = httpResponse.value(forHTTPHeaderField: \"Date\"),\n        let cacheControl = httpResponse.value(forHTTPHeaderField: \"Cache-Control\") {\n\n        print(\"Request1 date: \\(date)\")\n        print(\"Request1 Cache Header: \\(cacheControl)\")\n    }\n}\ntask.resume()\n\nsleep(5)\n\nlet task2 = URLSession.shared.dataTask(with: url) { (data , response, error) in\n    if let httpResponse = response as? HTTPURLResponse,\n        let date = httpResponse.value(forHTTPHeaderField: \"Date\"),\n        let cacheControl = httpResponse.value(forHTTPHeaderField: \"Cache-Control\") {\n\n        print(\"Request2 date: \\(date)\")\n        print(\"Request2 Cache Header: \\(cacheControl)\")\n    }\n\n    if let error = error {\n        print(error.localizedDescription)\n\n        if let cachedResponse = URLSession.shared.configuration.urlCache?.cachedResponse(for: request),\n            let httpResponse = cachedResponse.response as? HTTPURLResponse,\n            let date = httpResponse.value(forHTTPHeaderField: \"Date\") {\n\n            print(\"cached: \\(date)\")\n        }\n    }\n}\ntask2.resume()\n\nNow if we follow the same test as before:\n\n\n  Run the playground\n  Wait for first request to finish\n  Activate network conditioner with 100% packet loss\n\n\nWhat we should see in the console is this:\n\nRequest1 date: Sun, 28 Jun 2020 07:03:48 GMT\nRequest1 Cache Header: max-age=3\nThe request timed out.\ncached: Sun, 28 Jun 2020 07:03:48 GMT\n\n\nSo what is happening here?\n\n\n  The first request is completing successfully so we can see the date and cache header info. The same as before.\n  The seconds request is failing, hence the request timeout error\n  However this time, as the request has failed we are fetching the previously made request response from the cache and outputting the header from that.\n\n\nNow that we have shown how to grab cached requests from the cache, let’s wrap this up in a nice way so we can reuse it if we wish\n\n\n\n\n\n\nWrapping it up\n\nFirst of all lets create a standard swift example, then we will have a look at how we can do this in Combine and some of the challenges in doing so.\n\nextension URLSession {\n    // 1\n    func dataTask(with url: URL,\n                  cachedResponseOnError: Bool,\n                  completionHandler: @escaping (Data?, URLResponse?, Error?) -&gt; Void) -&gt; URLSessionDataTask {\n\n        return self.dataTask(with: url) { (data, response, error) in\n            // 2\n            if cachedResponseOnError,\n                let error = error,\n                let cachedResponse = self.configuration.urlCache?.cachedResponse(for: URLRequest(url: url)) {\n\n                completionHandler(cachedResponse.data, cachedResponse.response, error)\n                return\n            }\n\n            // 3\n            completionHandler(data, response, error)\n        }\n    }\n}\n\nSo let’s walk through what we are doing here:\n\n\n  We have created a method the same as the standard dataTask method on URLSession. However we have added a bool to control whether we would like to return the cached response on receiving a network error.\n  Here we take the example we used earlier in our example and applied it to this method. First we check whether we should return the cached response based on our cachedResponseOnError parameter. Then check to see if we do have an error, if we do then attempt to grab the cached response from the URLCache and return it’s data and response objects along with the error.\n  In the case where any of the above fails we simply return everything exactly as it was in returned by the normal dataTask method.\n\n\nAs the completion handler returns Data, URLResponse and Error we are able to return the data and response even if there is an error. That is a bit of a disadvantage in this case as the function caller needs to be aware that they may receive an error but also the cached response as well so need to cater for those scenario themselves.\n\n\n\n\n\n\nCombine\n\nHopefully you have at least heard of Combine even if you haven’t had chance to use it yet in a production app. It is Apple’s own version of a reactive framework. Those of you who have already been using RxSwift will be right at home. We aren’t going to go into too much detail about what Combine is but here is a definition of what reactive programming is:\n\n\n  In computing, reactive programming is a declarative programming paradigm concerned with data streams and the propagation of change\n\n\nIn more simplistic terms, reactive programming uses a observer pattern to allow classes to monitor different streams of data or state. When this state changes it emits an event with the new value which can trigger other streams to perform work or update such as UI code. If you are familier with KVO you will understand the basic concept. However reactive programming is far less painful and a lot more powerful than KVO.\n\nNow the approach described in the previous section works fine in the case of the completionHandler as it allows us to return all 3 items to the caller regardless of what happens. However in combine streams are designed to either return a value OR an error.\n\nFirst of all let’s look at a simple example:\n\n// 1\ntypealias ShortOutput = URLSession.DataTaskPublisher.Output\n\nextension URLSession {\n    // 2\n    func dataTaskPublisher(for url: URL,\n                           cachedResponseOnError: Bool) -&gt; AnyPublisher&lt;ShortOutput, Error&gt; {\n\n        return self.dataTaskPublisher(for: url)\n            // 3\n            .tryCatch { [weak self] (error) -&gt; AnyPublisher&lt;ShortOutput, Never&gt; in\n                // 4\n                guard cachedResponseOnError,\n                    let urlCache = self?.configuration.urlCache,\n                    let cachedResponse = urlCache.cachedResponse(for: URLRequest(url: url)) \n                else {\n                    throw error\n                }\n\n                // 5\n                return Just(ShortOutput(\n                    data: cachedResponse.data,\n                    response: cachedResponse.response\n                )).eraseToAnyPublisher()\n        // 6\n        }.eraseToAnyPublisher()\n    }\n}\n\nSo let’s step through what is happening here:\n\n\n  First I am creating a typealias of the dataTaskPublisher.Output. This is mostly for code formatting reasons as the string is very long. This is simply a Data object and a URLResponse object in a tuple.\n  Here we have setup our function with the cachedResponseOnError flag the same as before. We are returning a publisher with our type aliased output.\n  First we call the standard dataTaskPublisher method to setup our request. We immediately chain that publisher using the new tryCatch. So what does this do? “Handles errors from an upstream publisher by either replacing it with another publisher or throwing a new error.” So here we catch any connection errors from the dataTaskPublisher and we can either throw another error or send another publisher down the chain.\n  So the same as our pure Swift example we attempt to fetch our response from the cache, except here if we fail to find anything in the cache we just rethrow the same error we received in the try catch block so it can be handled further down the stream.\n  If we were able to find a response in the cache then we use the Just publisher to send the new value down the stream wrapping our cached response.\n  We erase the types to AnyPublisher using type erasure so items further down the stream don’t need to know the types. For more info on type erasure see my previous post.\n\n\nNow let’s take our previous test and adapt it so we can see this in action:\n\n// 1\nlet url = URL(string: \"https://postman-echo.com/response-headers?Content-Type=text/html&amp;Cache-Control=max-age=3\")!\nlet publisher = URLSession.shared.dataTaskPublisher(for: url, cachedResponseOnError: true)\n\n// 2\nlet token = publisher\n    .sink(receiveCompletion: { (completion) in\n        switch completion {\n        case .finished:\n            break\n        case .failure(let error):\n            print(error.localizedDescription)\n        }\n    }) { (responseHandler: URLSession.DataTaskPublisher.Output) in\n        if let httpResponse = responseHandler.response as? HTTPURLResponse,\n            let date = httpResponse.value(forHTTPHeaderField: \"Date\"),\n            let cacheControl = httpResponse.value(forHTTPHeaderField: \"Cache-Control\") {\n\n            print(\"Request1 date: \\(date)\")\n            print(\"Request1 Cache Header: \\(cacheControl)\")\n        }\n    }\n\n// 3\nsleep(5)\n\n// 4\nlet token2 = publisher\n    .sink(receiveCompletion: { (completion) in\n        switch completion {\n        case .finished:\n            break\n        case .failure(let error):\n            print(error.localizedDescription)\n        }\n    }) { (responseHandler: URLSession.DataTaskPublisher.Output) in\n        if let httpResponse = responseHandler.response as? HTTPURLResponse,\n            let date = httpResponse.value(forHTTPHeaderField: \"Date\"),\n            let cacheControl = httpResponse.value(forHTTPHeaderField: \"Cache-Control\") {\n\n            print(\"Request2 date: \\(date)\")\n            print(\"Request2 Cache Header: \\(cacheControl)\")\n        }\n    }\n\nAs we have done with our other examples let’s step through and see what happens.\n\n\n  First we create our request as we did in the pure Swift example, and then create our new publisher using our newly created function.\n  Now in Combine, publisher’s only execute once there is an unsatisfied subscription. This happens whenever the sink function is called. The first closure is called when either the stream completes or an error throws (which also terminates the stream). The second closure is called whenever a new value is published from the stream. In this first case we can a tuple containing Data and a URLResponse. As before we inspect the date header of the request.\n  As before we sleep for 5 seconds (we have set a timeout of 3 on using the cache control headers)\n  This matches the same as step 2 however we changed the output.\n\n\nIf we follow the same steps as before and turn on packet loss using the network conditioner when we hit step 3 we should see a console log like below:\n\nRequest1 date: Tue, 30 Jun 2020 07:53:26 GMT\nRequest1 Cache Header: max-age=3\nRequest2 date: Tue, 30 Jun 2020 07:53:26 GMT\nRequest2 Cache Header: max-age=3\n\n\nNow, this proves that we are returning our cached response in the second request as we have no connection and we are still receiving a response. However what is the problem here?\n\nThere is no error\n\nThe above implementation works fine if we just want to display cached data. However you may wish to inform the user that there was a connection failure and they are viewing old / stale information. So how can we get around this? In order to send the cached value, then the error we would need to create a custom Combine publisher. We won’t cover that here as that is a post in itself.\n\n\n\n\n\n\nConclusion\n\nWe have shown how we can make use of built in functionality of URLSession and URLCache along with the HTTP standard headers to provide simple and basic offline caching.\n\nAdvantages\n\n\n  Simple implementation, doesn’t require 3rd party frameworks or complex relational databases\n  Makes use of 1st party frameworks and relies on currently available standards (HTTP)\n  Concurrency handled automatically\n\n\nDisadvantages\n\n\n  Relies on cache-control headers being correctly used in the API being consumed\n  URLSession cache policies need to be configured correctly\n  Doesn’t support more complex caching requirements / rules if needed\n  URLCache will delete the cache if device memory becomes full, something to bear in mind using this approach\n\n\nIn summary, this approach is simple and provides basic offline functionality for your app. If you have more complex needs / requirements for caching your data then other approaches may be more suitable.\n\nFeel free to download the playground and play around with the examples yourself\n",
      tags: ["swift","combine","generics","networking","caching"],
      id: 19
    });
    

    index.add({
      title: "Simple JSON decoder in Swift and Combine",
      category: ["networking"],
      content: "Intro\n\nPretty much every app nowadays requires you to connect to the internet to access some content. The majority of those apps use JSON to communicate that data from the backend systems.\n\nThere is high chance you will have some code in your app to download, parse and return objects for your app to use from an endpoint (unless you are using a network library such as Alamofire)\n\nIn this post we are going to demonstrate how we can use Generics and Codable to help us build a simple reusable JSON decoder to download and parse responses from our endpoints.\n\n\n\n\n\n\nBuilding our codable objects\n\nThe first thing we need to do is build our codable objects. Objects that implement the Codable protocol allow Encoders and Decoders to encode or decode them to and from an external representation such as JSON.\n\nLet’s take the response from the sample endpoint below as an example:\n\nhttps://jsonplaceholder.typicode.com/users\n\n{\n    \"id\": 1,\n    \"name\": \"Leanne Graham\",\n    \"username\": \"Bret\",\n    \"email\": \"Sincere@april.biz\",\n    \"address\": {\n      \"street\": \"Kulas Light\",\n      \"suite\": \"Apt. 556\",\n      \"city\": \"Gwenborough\",\n      \"zipcode\": \"92998-3874\",\n      \"geo\": {\n        \"lat\": \"-37.3159\",\n        \"lng\": \"81.1496\"\n      }\n    },\n    \"phone\": \"1-770-736-8031 x56442\",\n    \"website\": \"hildegard.org\",\n    \"company\": {\n      \"name\": \"Romaguera-Crona\",\n      \"catchPhrase\": \"Multi-layered client-server neural-net\",\n      \"bs\": \"harness real-time e-markets\"\n    }\n  }\n\nYou can create codable classes yourself by hand. In simple examples this can be fairly straight forward, however if you have a response that has a more complex structure, doing so can be time consuming and error prone.\n\nTo create our codable objects we can use a generator, my weapon of choice is QuickType. We just paste in the JSON that is returned from the posts endpoint and it automatically generates the Codable structs for us. Easy!\n\nIf we paste in our post response, we should end up with some code looking like this:\n\n// MARK: - User\nstruct User: Codable {\n    let id: Int\n    let name, username, email: String\n    let address: Address\n    let phone, website: String\n    let company: Company\n}\n\n// MARK: - Address\nstruct Address: Codable {\n    let street, suite, city, zipcode: String\n    let geo: Geo\n}\n\n// MARK: - Geo\nstruct Geo: Codable {\n    let lat, lng: String\n}\n\n// MARK: - Company\nstruct Company: Codable {\n    let name, catchPhrase, bs: String\n}\n\ntypealias Users = [User]\n\nHow easy was that?! Obviously we will still need to check the structs, in the example above none of the fields are optional which means data must be passed in otherwise our decoding will fail. We don’t need to worry about that here, but worth remembering when checking the generated code in your examples.\n\n\n\n\n\n\nURLSession extension and Generics\n\nTo solve our problem we are going to wrap the existing URLSession dataTask method. I’m sure if you have done any kind of request work in pure swift you will have used this method in some form so we aren’t going to go into the details of how it works.\n\nextension URLSession {\n\n\t// 1\n    enum SessionError: Error {\n        case noData\n        case statusCode\n    }\n\n    /// Wraps the standard dataTask method with a JSON decode attempt using the passed generic type.\n    /// Throws an error if decoding fails\n    /// - Parameters:\n    ///   - url: The URL to be retrieved.\n    ///   - completionHandler: The completion handler to be called once decoding is complete / fails\n    /// - Returns: The new session data task\n\n    // 2 \n    func dataTask&lt;T: Decodable&gt;(with url: URL,\n                                completionHandler: @escaping (T?, URLResponse?, Error?) -&gt; Void) -&gt; URLSessionDataTask {\n\n        // 3\n        return self.dataTask(with: url) { (data, response, error) in\n        \t// 4\n            guard error == nil else {\n                completionHandler(nil, response, error)\n                return\n            }\n\n            // 5\n            if let response = response as? HTTPURLResponse,\n                (200..&lt;300).contains(response.statusCode) == false {\n                completionHandler(nil, response, SessionError.statusCode)\n            }\n\n            // 6\n            guard let data = data else {\n                completionHandler(nil, response, SessionError.noData)\n                return\n            }\n\n            // 7\n            do {\n                let decoded = try JSONDecoder().decode(T.self, from: data)\n                completionHandler(decoded, response, nil)\n            } catch(let error) {\n                completionHandler(nil, response, error)\n            }\n        }\n    }\n}\n\nSo let’s step through this code sample step by step:\n\n\n  First of we have defined a custom error for this extension, this is returned when no data has been returned from the request, covered in point 6. We also have an error case if we get an HTTPURLResponse with an incorrect status code, covered in point 5.\n  Here we are making use of Generics to allow any type T being returned from this function as long as type T implements the Decodable protocol (which we need it to inorder to use the JSONDecoder)\n  As discussed, here we are calling the existing dataTask method to run our request.\n  First thing we do once the request has returned is check to see if there was a request error, if so we call the completion handler with the response and the error.\n  The second check we perform is to check the status code if we have received an HTTPURLResponse. Note we aren’t stopping the code here if we don’t get a HTTPURLResponse as you could use this function to load a local JSON file for example, not just a remote URL. Any status code in the 200-299 range is considered a successful request, if we receive a status code outside this range we return an error along with the response for further processing by whoever passed the completion handler.\n  The third check we perform is to unwrap data ready for decoding. If this fails (as in it’s nil) then we call the completionHandler with the response and our custom error defined in step 1.\n  The final piece of the puzzle is to attempt to decode the data into type T we defined in the method signature as part of step 2. If this succeeds we can call our completion handler with our decoded type and response. If it throws an error we capture the error and return it using the catch block below.\n\n\n\n\n\n\n\nSee it in action\n\nNow that we have put our function together, let’s take it for a test drive.\n\nlet url = URL(string: \"https://jsonplaceholder.typicode.com/users\")!\nlet task = URLSession.shared.dataTask(with: url, completionHandler: { (users: Users?, response, error) in\n    if let error = error {\n        print(error.localizedDescription)\n        return\n    }\n\n    users?.forEach({ print(\"\\($0.name)\\n\") })\n})\ntask.resume()\n\nThis shouldn’t look too scarey, infact if you have used the standard dataTask functions in your code previously this should look very familiar. The only different here being that our completion handler now returns our Codable User objects rather than just a blob of Data like before.\n\nHopefully that example makes sense and gives you a nice simple way to perform a request and have it decode some JSON into a struct / class. Now let’s have a look at some reactive programming using Combine.\n\nCombine\n\nHopefully you have at least heard of Combine even if you haven’t had chance to use it yet in a production app. It is Apple’s own version of a reactive framework. Those of you who have already been using RxSwift will be right at home. We aren’t going to go into too much detail about what Combine is but here is a definition of what reactive programming is:\n\n\n  In computing, reactive programming is a declarative programming paradigm concerned with data streams and the propagation of change\n\n\nIn more simplistic terms, reactive programming uses a observer pattern to allow classes to monitor different streams of data or state. When this state changes it emits an event with the new value which can trigger other streams to perform work or update such as UI code. If you are familier with KVO you will understand the basic concept. However reactive programming is far less painful and a lot more powerful than KVO.\n\nNow let’s take the previous pure Swift example and see how we can use it in Combine. The Combine framework adds new reactive functionality to the URLSession in the form of the dataTaskPublisher function.\n\nextension URLSession {\n\n\t// 1\n    enum SessionError: Error {\n        case statusCode(HTTPURLResponse)\n    }\n\n    /// Function that wraps the existing dataTaskPublisher method and attempts to decode the result and publish it\n    /// - Parameter url: The URL to be retrieved.\n    /// - Returns: Publisher that sends a DecodedResult if the response can be decoded correctly.\n\n    // 2\n    func dataTaskPublisher&lt;T: Decodable&gt;(for url: URL) -&gt; AnyPublisher&lt;T, Error&gt; {\n    \t// 3\n        return self.dataTaskPublisher(for: url)\n        \t// 4\n            .tryMap({ (data, response) -&gt; Data in\n                if let response = response as? HTTPURLResponse,\n                    (200..&lt;300).contains(response.statusCode) == false {\n                    throw SessionError.statusCode(response)\n                }\n\n                return data\n            })\n            // 5\n            .decode(type: T.self, decoder: JSONDecoder())\n            // 6\n            .eraseToAnyPublisher()\n    }\n}\n\nSimilar to our previous example we have extended URLSession to provide this functionality. Let’s step through it:\n\n\n  As with the pure Swift example we are defining a custom error here to handle when we receive a status code that is not a success. The difference being here we are attaching the response to the error as we don’t have a completionHandler in Combine. That way whoever is handling the error can inspect the response and see why it failed.\n  Here we are defining the method, again using generics to only accept a type T that has implemented the  Decodable protocol. The function returns a publisher who returns our decoded object.\n  As discussed previously, we are simply wrapping the existing dataTaskPublisher method.\n  Now here is where things start to become reactive. The tryMap function is similar to the standard map function in that it attempts to convert / transfrom elements from one type to another. However the difference here being that it is almost wrapped in a try. In this case you can include code in the closure which throws errors and they will be pushed downstream and handled later instead of needing a do block. Similar to our pure Swift example, we are checking we have a valid status code, if not we throw our custom error. If not we map our data ready to be decoded.\n  Here we are using the built in decode method to attempt to decode our custom type using the JSONDecoder. Similar to the tryMap function above, any errors are pushed downstream to be handler later.\n  The final piece of the puzzle is to use type erasure. This removes the publisher class type and makes it AnyPublisher. For more info on type erasure see my previous post\n\n\n\n\n\n\n\nCombine in action\n\nNow that we have built our wrapper class let’s take a look at this in action:\n\nlet url = URL(string: \"https://jsonplaceholder.typicode.com/users\")!\n\nlet token = URLSession.shared.dataTaskPublisher(for: url)\n\t// 1\n    .sink(receiveCompletion: { (completion) in\n        switch completion {\n        // 2\n        case .finished:\n            break\n        case .failure(let error):\n            print(error.localizedDescription)\n        }\n    }) { (users: Users) in\n    \t// 3\n        users.forEach({ print(\"\\($0.name)\\n\") })\n    }\n\n\n  Here we have called our newly created dataTaskPublisher method which has returned our publisher. This is where reactive programming comes in. All of the code inside the dataTaskPublisher has not executed yet. We have simply returned a publisher who is waiting for a subscriber to come along and listen. A publisher will not execute unless a subscription has not been fulfilled. To subscribe to a stream we use the sink method. If you think of the chain of reactive methods flowing into a sink at the bottom, that is the best analogy here.\n  The sink method has 2 parts. The first closure defines what happens once the stream is completed. Now this can come in the form of a finished state, which means the stream has completed what is doing and will no longer emit any more events. Or failure, which means some item further up the stream has raised an error which flows down into this sink where it can be handled.\n  The second closure defines what we would like to do each time the event stream emits a change. In this case the publisher will send a users array once it has finished loading, here we are just printing out the user names.\n\n\nFinally\n\nWhat have we learnt:\n\n\n  We have used QuickType to convert our JSON into codable structs for decoding.\n  Wrapped the existing URLSession dataTask method with our own using Generics so we can using any Codable type to decode the response.\n  Similarly, using reactive programming and Apple’s new Combine framework have created our own Generic wrapper for the existing dataTaskPublisher function.\n\n\nFeel free to download the playground and play around with the examples yourself\n",
      tags: ["swift","combine","generics","networking"],
      id: 20
    });
    

    index.add({
      title: "What is type erasure in Swift",
      category: ["type-erasure"],
      content: "Intro\n\n\n  Wtf is type erasure?\n  Why do I need it?\n  This seems complicated?\n  Isn’t there a simpler way?\n\n\nThese are are just some of the questions I found myself asking once I first starting exploring type erasure. Like many other developers, I have been making use of protocols in my code to remove dependencies and make my classes easy to unit test. It wasn’t until I then started to add generics to my protocols that I discovered the need to apply type erasure.\n\nHaving read many blog posts and guides about type erasure I still came away confused as to what it was, why it was needed and why it seemed to add so much complexity. By trying to add generics to protocols in a project I was working on I finally saw the light! I am going to try and walk you through the topic using an example which is similar to the one I was trying to solve in my project. Hopefully this will help those of you who are looking to understand the topic further in the same way it helped me.\n\n\n\n\n\n\nGenerics and Associated Types\n\nI am assuming that as you are here you have a fairly advanced knowledge of Swift and have potentially begun or have been using protocols with generics in your code. Below is a simple protocol called Fetchable. The idea of the protocol is to go and fetch some objects of type FetchType from somewhere and call the completion handler with the result once it’s finished whatever it is doing.\n\nprotocol Fetchable {\n    associatedtype FetchType\n\n    func fetch(completion: ((Result&lt;FetchType, Error&gt;) -&gt; Void)?)\n}\n\nNow that we have our protocols lets create a couple of structs to implement the protocol.\n\nstruct User {\n    let id: Int\n    let name: String\n}\n\nstruct UserFetch: Fetchable {\n    typealias FetchType = User\n\n    func fetch(completion: ((Result&lt;FetchType, Error&gt;) -&gt; Void)?) {\n        let user = User(id: 1, name: \"Phil\")\n        completion?(.success(user))\n    }\n}\n\nSo here we have created a dummy data class, User. Our fetch struct has implemented the generic protocol and has specified the type of object that will be returned in the protocol using a typealias. Everything here is great, we can implement this protocol as many times as we like and return whatever object types we want without the need to create a new protocol for each one.\n\nThe problem\n\nNow, here in lies the problem. If we wish to hold a reference to an object that has implemented this protocol. How do we know what type it is going to return? See the below example:\n\nstruct SomeStruct {\n    let userFetch: Fetchable\n}\n\nWhat you will also find here is that you will see an error, something like the below\n\n\n  Protocol ‘Fetchable’ can only be used as a generic constraint because it has Self or associated type requirements\n\n\nSo we can’t even use this type as a reference to the object, as it has an associated type which we cannot see at this point and have no way of specifying.\n\nNow we could do something like below, however this creates a dependency between SomeStruct and the userFetch object. If we are following the SOLID principles we want to avoid having dependencies and hide implementation details.\n\nstruct SomeStruct {\n    let userFetch: UserFetch\n}\n\nOk, so let’s try adding a type like we do with other generic types such as arrays and dictionaries:\n\nstruct SomeStruct {\n    let userFetch: Fetchable&lt;User&gt;\n}\n\nIf you try the above you will probably end up with an error something like this:\n\n\n  Cannot specialize non-generic type ‘Fetchable’\n\n\nSee generic protocols, unlike generic types cannot have their type inferred in the type declaration. The type is only specified during implementation.\n\nType Erasure to the rescue\n\nSo this is where type erasure comes in. In order for us to know the type returned we need to implement a new class that can be used to infer the type of object returned so that we know what to expect when we call fetch.\n\n// 1\nstruct AnyFetchable&lt;T&gt;: Fetchable {\n    // 2\n    typealias FetchType = T\n\n    // 3\n    private let _fetch: (((Result&lt;T, Error&gt;) -&gt; Void)?) -&gt; Void\n\n    // 4\n    init&lt;U: Fetchable&gt;(_ fetchable: U) where U.FetchType == T {\n        _fetch = fetchable.fetch\n    }\n\n    // 5\n    func fetch(completion: ((Result&lt;T, Error&gt;) -&gt; Void)?) {\n        _fetch(completion)\n    }\n}\n\nWhoooa! There is a lot going on here so let us go through it piece by piece to explain what is happening.\n\n\n  Here our AnyFetchable class is implementing the Fetchable protocol. But also we see that we now have a generic type specification. This means that we can specify what type is being used while storing a reference to this struct.\n  Our generic type T being specified in the line above is then used in the typealias and mapped to the FetchType associated value of the protocol.\n  Now this is where things get fiddly. In order for us to erase the type of the injected class we must first create an attribute which is a closure with a matching signature for each function in the protocol. In this scenario we only have 1 method which is the fetch method. Here you can see the fetch attribute has the same method signature as the one in the protocol.\n  Lets break this down a bit. First of all we are saying that this init method is only available for an object that has implemented Fetchable, called U. The where clause at the end of the line is a generic type restriction which states that the FetchType of the Fetchable U must be the same as the one being used in this class. This might not make too much sense right now, but stay with me. When the fetchable type U is passed in, we store a reference to its fetch method in our own internal variable. This is what helps us erase the type, we store a reference to all of the objects methods without actually storing a reference to the object. That way we don’t need to know the type.\n  Here is our implementation of the Fetchable protocols fetch method, however all we are doing is calling the reference to passed in objects fetch method and calling that instead.\n\n\nHopefully some of this makes sense, some of this may be new or confusing especially point 4. Let’s show how we can use our class in this example.\n\nstruct SomeStruct {\n    let userFetch: AnyFetchable&lt;User&gt;\n}\n\n// 1\nlet userFetch = UserFetch()\n\n// 2\nlet anyFetchable = AnyFetchable&lt;User&gt;(userFetch)\n\n// 3\nlet someStruct = SomeStruct(userFetch: anyFetchable)\n\n// 4\nsomeStruct.userFetch.fetch { (result) in\n    switch result {\n    case .success(let user):\n        print(user.name)\n    case .failure(let error):\n        print(error)\n    }\n}\n\n\n  First we create an instance of our UserFetch object from earlier in the example that returns our example user.\n  We pass this into our AnyFetchable object. Now remember we had a generic type constraint on our init in point 4 of the previous example. This is being satisfied because we have specified that the AnyFetchable should return a User type, and the UserFetch object we are passing in has the FetchType User.\n  We can now pass in the AnyFetchable to our struct.\n\n\n\n\n\n\n\nWhy?\n\nNow you are probably thinking, why do all of this? Well, let’s try another example:\n\n// New Dave user struct\nstruct DaveFetch: Fetchable {\n    typealias FetchType = User\n\n    func fetch(completion: ((Result&lt;FetchType, Error&gt;) -&gt; Void)?) {\n        let user = User(id: 2, name: \"Dave\")\n        completion?(.success(user))\n    }\n}\n\n// Example implementation 2\nlet daveFetch = DaveFetch()\nlet anyDaveFetchable = AnyFetchable&lt;User&gt;(daveFetch)\nlet someDaveStruct = SomeStruct(userFetch: anyDaveFetchable)\n\nsomeDaveStruct.userFetch.fetch { (result) in\n    switch result {\n    case .success(let user):\n        print(user.name)\n    case .failure(let error):\n        print(error)\n    }\n}\n\nSo here we have created a new object that implements Fetchable and returns a user called Dave. We can then pass this into our SomeStruct using our type erasure class and it works exactly the same. The SomeStruct class doesn’t need to be changed in order to work with the new dave class as it’s type has been erased. In a production app we could inject any class we want as long as it fetches a User, whether that comes from the web, core data, the file system. It doesn’t matter we could switch it at any time without making changes to our SomeStruct class.\n\nFinally\n\nThe last example here is that we can use our Any class for other types, not just User. See the example below:\n\n// Product Type\nstruct Product {\n    let id: Int\n    let title: String\n    let price: String\n}\n\nstruct ProductFetch: Fetchable {\n    typealias FetchType = Product\n\n    func fetch(completion: ((Result&lt;FetchType, Error&gt;) -&gt; Void)?) {\n        let product = Product(id: 1, title: \"My Product\", price: \"10.99\")\n        completion?(.success(product))\n    }\n}\n\nlet productFetch = ProductFetch()\nlet anyProductFetch = AnyFetchable&lt;Product&gt;(productFetch)\nanyProductFetch.fetch { (result) in\n    switch result {\n    case .success(let product):\n        print(product.title)\n    case .failure(let error):\n        print(error)\n    }\n}\n\nSimilar to our user example, we have created a new Product object and a fetcher that returns a product object. However we can re-use our AnyFetchable here but specifying the return type as Product.\n\nThere is a lot to cover and understand here and hopefully this helps make some sense of type erasure and what it is used for. More importantly how to implement your own Any type erasure class for your own protocols so that they can be referenced in your code.\n\nDownload the playground and play around with the examples yourself\n\n\n\n\n\n",
      tags: ["swift","advanced","protocols","generics"],
      id: 21
    });
    


var store = [{
    "title": "Fostering a Culture of Continuous Learning and Improvement: A Comprehensive Guide for Engineering Managers",
    "link": "/management/fostering-a-culture-of-continuous-learning-and-improvement-a-comprehensive-guide-for-engineering-managers.html",
    "image": null,
    "date": "September 28, 2023",
    "category": ["management"],
    "excerpt": "In the dynamic and evolving field of engineering, sustaining a culture of continuous learning and improvement is crucial. It is..."
},{
    "title": "The Role of Emotional Intelligence in Engineering Management",
    "link": "/management/the-role-of-emotional-intelligence-in-engineering-management.html",
    "image": null,
    "date": "September 21, 2023",
    "category": ["management"],
    "excerpt": "Engineering management is often perceived through a purely technical lens, with emphasis placed on knowledge and expertise in software development,..."
},{
    "title": "Influencing and driving change as an Engineering Manager",
    "link": "/management/influencing-and-driving-change-as-an-engineering-manager.html",
    "image": null,
    "date": "August 28, 2023",
    "category": ["management"],
    "excerpt": "Change is an inevitable part of business and technology. As an engineering manager, you’re often at the forefront of driving..."
},{
    "title": "Structuring Your First 1-to-1 as an Engineering Manager",
    "link": "/management/structuring-your-first-1-to-1-as-an-engineering-manager.html",
    "image": null,
    "date": "August 5, 2023",
    "category": ["management"],
    "excerpt": "Your first 1-to-1 meeting with each team member is a foundational event in your tenure as an engineering manager. It..."
},{
    "title": "Best Practices for Giving Effective Feedback in Engineering Management",
    "link": "/management/best-practices-for-giving-effective-feedback-in-engineering-management.html",
    "image": null,
    "date": "July 16, 2023",
    "category": ["management"],
    "excerpt": "Feedback is a fundamental part of management, especially in the field of engineering where precision, continual learning, and improvement are..."
},{
    "title": "Best Practices for Managing Employee Career Development in Engineering Management",
    "link": "/management/best-practices-for-managing-employee-development-in-engineering-management.html",
    "image": null,
    "date": "June 30, 2023",
    "category": ["management"],
    "excerpt": "The dynamic field of engineering is characterized by rapid technological advancements, shifting market demands, and an ever-evolving professional landscape. Consequently,..."
},{
    "title": "Best Practices for Preventing and Managing Employee Burnout in Engineering Management",
    "link": "/management/best-practices-for-preventing-and-managing-employee-burnout-in-engineering-management.html",
    "image": null,
    "date": "June 15, 2023",
    "category": ["management"],
    "excerpt": "In the fast-paced, high-pressure world of engineering, employee burnout is a real and present danger. Burnout can lead to decreased..."
},{
    "title": "Best Practices for Handling Difficult Conversations in Engineering Management",
    "link": "/management/best-practices-for-handling-difficult-conversations-in-engineering-management.html",
    "image": null,
    "date": "June 4, 2023",
    "category": ["management"],
    "excerpt": "In the dynamic field of engineering management, difficult conversations are inevitable. Whether it’s delivering critical feedback, discussing a project setback,..."
},{
    "title": "Best Practices for Delegating Effectively in Engineering Management",
    "link": "/management/best-practices-for-delegating-effectively-in-engineering-management.html",
    "image": null,
    "date": "May 31, 2023",
    "category": ["management"],
    "excerpt": "Delegation is one of the most critical skills for any manager, especially in the field of engineering. With its inherently..."
},{
    "title": "Best Practices for Managing Conflict in Engineering Management",
    "link": "/management/best-practices-for-managing-conflict.html",
    "image": null,
    "date": "May 21, 2023",
    "category": ["management"],
    "excerpt": "Conflict is an inevitable part of any organization, and engineering teams are no exception. As an engineering manager, dealing with..."
},{
    "title": "Transitioning from Engineer to Engineering Manager: The Uncharted Terrain",
    "link": "/management/transitioning-from-engineer-to-engineering-manager.html",
    "image": null,
    "date": "May 14, 2023",
    "category": ["management"],
    "excerpt": "In the world of tech, transitioning from the role of an engineer to an engineering manager is often viewed as..."
},{
    "title": "SOLID Principles in Swift - Dependency Inversion Principle",
    "link": "/architecture/solid-principles-in-swift-dependency-inversion-principle.html",
    "image": null,
    "date": "May 9, 2023",
    "category": ["architecture"],
    "excerpt": "Background In this series of posts we are going to be covering the SOLID principles of software development. These are..."
},{
    "title": "SOLID Principles in Swift - Interface Segragation Principle",
    "link": "/architecture/solid-principles-in-swift-interface-segragation-principle.html",
    "image": null,
    "date": "May 3, 2022",
    "category": ["architecture"],
    "excerpt": "Background In this series of posts we are going to be covering the SOLID principles of software development. These are..."
},{
    "title": "SOLID Principles in Swift - Liskov Substitution Principle",
    "link": "/architecture/solid-principles-in-swift-liskov-substitution-principle.html",
    "image": null,
    "date": "April 18, 2022",
    "category": ["architecture"],
    "excerpt": "Background In this series of posts we are going to be covering the SOLID principles of software development. These are..."
},{
    "title": "SOLID Principles in Swift - Open / Closed Principle",
    "link": "/architecture/solid-principles-in-swift-open-closed-principle.html",
    "image": null,
    "date": "May 7, 2021",
    "category": ["architecture"],
    "excerpt": "Background In this series of posts we are going to be covering the SOLID principles of software development. These are..."
},{
    "title": "SOLID Principles in Swift - Single Responsibility Principle",
    "link": "/architecture/solid-principles-in-swift-single-responsibility-principle.html",
    "image": null,
    "date": "April 10, 2021",
    "category": ["architecture"],
    "excerpt": "Background In this series of posts we are going to be covering the SOLID principles of software development. These are..."
},{
    "title": "Programmatic routing in SwiftUI",
    "link": "/swiftui/programmatic-routing-swiftui.html",
    "image": null,
    "date": "February 23, 2021",
    "category": ["swiftUI"],
    "excerpt": "Background As I’m sure any iOS developer now knows, the future of iOS app development is SwiftUI. Apple’s new UI..."
},{
    "title": "Using protocols, ObservableObject and @Published property wrappers in SwiftUI",
    "link": "/swiftui/using-protocols-observableobject-published-property-wrappers-swiftui.html",
    "image": null,
    "date": "February 9, 2021",
    "category": ["swiftUI"],
    "excerpt": "Background As I’m sure any iOS developer now knows, the future of iOS app development is SwiftUI. Apple’s new UI..."
},{
    "title": "Repository Pattern in Swift",
    "link": "/architecture/repository-pattern-in-swift-and-combine.html",
    "image": null,
    "date": "July 19, 2020",
    "category": ["architecture"],
    "excerpt": "Background All apps developed require data of some description. This data is stored somewhere, could be on the device itself,..."
},{
    "title": "Simple offline caching in Swift and Combine",
    "link": "/networking/simple-offline-caching-in-swift-and-combine.html",
    "image": null,
    "date": "July 1, 2020",
    "category": ["networking"],
    "excerpt": "Background Following on from the previous post where we explored simple JSON decoding. In this post we are going to..."
},{
    "title": "Simple JSON decoder in Swift and Combine",
    "link": "/networking/simple-json-decoder-in-swift-and-combine.html",
    "image": null,
    "date": "June 11, 2020",
    "category": ["networking"],
    "excerpt": "Intro Pretty much every app nowadays requires you to connect to the internet to access some content. The majority of..."
},{
    "title": "What is type erasure in Swift",
    "link": "/type-erasure/what-is-type-erasure.html",
    "image": null,
    "date": "June 3, 2020",
    "category": ["type-erasure"],
    "excerpt": "Intro Wtf is type erasure? Why do I need it? This seems complicated? Isn’t there a simpler way? These are..."
}]

$(document).ready(function() {
    $('#search-input').on('keyup', function () {
        var resultdiv = $('#results-container');
        if (!resultdiv.is(':visible'))
            resultdiv.show();
        var query = $(this).val();
        var result = index.search(query);
        resultdiv.empty();
        $('.show-results-count').text(result.length + ' Results');
        for (var item in result) {
            var ref = result[item].ref;
            var searchitem = '<li><a href="'+ hostname + store[ref].link+'">'+store[ref].title+'</a></li>';
            resultdiv.append(searchitem);
        }
    });
});