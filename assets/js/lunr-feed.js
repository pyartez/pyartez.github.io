var hostname = "https://pyartez.github.io";
var index = lunr(function () {
    this.field('title')
    this.field('content', {boost: 10})
    this.field('category')
    this.field('tags')
    this.ref('id')
});



    index.add({
      title: "Weekly Mobile Digest - 12 Feb 2021",
      category: ["News"],
      content: "Hyundai says it is not in talks with Apple to make self-driving cars\nWe keep hearing lots of interesting rumours regarding the self driving car project at Apple. The project supposedly named ‘Titan’ first rumoured 2014–2015 looked dead in the water after a number of employees were laid off in 2019.\n\nRecently news had been swirling that Apple were engaging in talks with car manufacturers but has been put to bed. Still intrigued to see where this goes. Will they look to make their own car? Or look to sell the tech required to automakers to use in their own vehicles?\n\nMacBooks might be losing the Touch Bar\nHonestly I can’t say I’ll miss it. While on the surface it looks like a neat feature in reality it was something that I rarely used as my main focus is always on my screen. Most people can touch type these days so having to stop and look down seems to have been a deal breaker. Maybe they have some analytics to back up my opinion!\n\nUsers can now unlock their iPhone with the Apple Watch if face mask is detected\nThis is a great feature and something I am very looking forward to. While I do like Face ID, it has been a pain since the beginning of the pandemic so have to constantly have to put in your passcode when out with a mask on. Oh how spoiled we have become by Touch ID / Face ID. Remember when the only way to unlock your phone was with a passcode?\n\niOS 14.5 lets users change the default music service for your iPhone\nAs a Spotify user myself, this has been a long time coming. It’s always frustrated me that I haven’t been able to control music playback using voice commands. Glad to see this change finally come through, hopefully their will be app updates soon to help support the integration\n\nGoogle looking to add Apple style anti-tracking feature to Android\nSeems a strange idea for a platform who’s main design goal is spy on end users as much as possible to facilitate better ad targeting. Sounds more like they want to be seen to be protecting user privacy as users are becoming more aware of the issues, but without actually doing anything to protect said users\n\nLeak reveals new Android 12 design\nGlad I’m not the only one who thought it looked a lot like iOS after viewing the screenshots. Continuing the trend of both platforms copying features / ideas from each other.\n\nApple Maps can now report accidents, hazards and speed checks\nWe’ve come a long way since Apple Maps disastrous launch and it’s great to see it getting these features. However I still feel it has a long way to go to winning back my confidence. I still find myself reluctantly using Google Maps for navigation.\n",
      tags: ["Apple","Android","Google"],
      id: 0
    });
    

    index.add({
      title: "Using protocols, ObservableObject and @Published property wrappers in SwiftUI",
      category: ["SwiftUI"],
      content: "Background\n\nAs I’m sure any iOS developer now knows, the future of iOS app development is SwiftUI. Apple’s new UI development language is now on it’s 2nd major release. While my own personal feeling is that the framework is not quite ready for prime time (much like when Swift first arrived. It’s missing some fairly key features) and we are perhaps a version or 2 away from it realistically being an option for being used to build a complete app. There is no denying that it is the future and when it works well, it makes building UI a lot easier.\n\nAs SwiftUI is the future, I’ve been investigating how teams might migrate their existing architectures across to the new technology. There a number of challenges presented by migrating to SwiftUI we will discuss below. As the title suggests we will be exploring how to use a presenter to control a SwiftUI view. It doesn’t matter which architecture you are using as such, whether it’s VIPER, MVVVM, VIP, MVP etc. As long as the logic and state of the view has been abstracted away from the view itself so it can be properly unit tested.\n\nExample\n\nList Item View\n\nLet’s start by creating an example in SwiftUI. We will create a simple list view to display some news for example. Let’s create a simple list view first of all:\n\n// 1\nstruct ListItemViewModel: Identifiable {\n    let id: Int\n    let title: String\n    let subTitle: String?\n    let image: String\n}\n\n// 2\nstruct ListItemView: View {\n    let viewModel: ListItemViewModel\n    \n    var body: some View {\n        HStack() {\n            Image(viewModel.image)\n            VStack(alignment: .leading) {\n                Text(viewModel.title)\n                    .font(.headline)\n                viewModel.subTitle.map({\n                    Text($0)\n                        .font(.subheadline)\n                })\n            }\n        }\n    }\n}\n\n// 3\nstruct ListItemView_Previews: PreviewProvider {\n    static var previews: some View {\n        ListItemView(\n            viewModel: ListItemViewModel(\n                id: 1,\n                title: \"Test Title\",\n                subTitle: \"Test Subtitle\",\n                image: \"first\"\n            )\n        )\n    }\n}\n\nThis is quite a straight forward view, but let’s step through it.\n\n\n  First of all we define our model for the view. We have an id so that we can conform to Identifiable. This allows SwiftUI to uniquely identify each model in the view and helps with performing things like animation and reordering. We also have a title, optional subTitle and an image string. Hopefully nothing here is too scary.\n  Now we define the view inself. Views in SwiftUI are simple structs that conform to the View protocol, rather than subclasses of UIView like they used to be in UIKit. Its a simple Hstack with an image view then 2 labels stacked on top of each other. See the screen grab below.\n  Finally we have the preview code to inject an example model to use in the preview.\n\n\n\n\nList View\n\nNow that we have the items in our list, lets create a simple list view that displays those items.\n\n// 1\nstruct ContentView: View {\n    let listItems: [ListItemViewModel]\n \n    var body: some View {\n        List(listItems) { item in\n            ListItemView(viewModel: item)\n        }\n    }\n}\n\n// 2\nstruct ContentView_Previews: PreviewProvider {\n    static var previews: some View {\n        let items = [ListItemViewModel(id: 1, title: \"test\", subTitle: \"test sub\", image: \"first\"),\n                    ListItemViewModel(id: 2, title: \"test2\", subTitle: \"test sub1\", image: \"first\"),\n                    ListItemViewModel(id: 3, title: \"test3\", subTitle: \"test sub2\", image: \"first\"),\n                    ListItemViewModel(id: 4, title: \"test4\", subTitle: \"test sub3\", image: \"first\"),\n                    ListItemViewModel(id: 5, title: \"test5\", subTitle: \"test sub4\", image: \"first\")]\n        \n        ContentView(listItems: items)\n    }\n}\n\nOk so what do we have here:\n\n\n  A simple ContentView who has an array of list item view models and a body. The body lists out the content of our list using the ListItemView we created earlier. Simple\n  Here we have some test data to show that our list is working. If we preview this view we will see something like this:\n\n\n\n\nThat’s wonderful, however it is not particularly dynamic. This is where a presenter or view model would come in. If we look at the description of MVP or MVVM we will see they have a similar role:\n\n\n  The presenter acts upon the model and the view. It retrieves data from repositories (the model), and formats it for display in the view.\n\n\nThere are further abstractions layers (such as interactors and use cases). However we are less concerned with them in this discussion and more on the relationship between the view and the presenter who is holding the state and logic of the view.\n\nAbstracting the state\n\nSo at the moment we have a pretty stateless SwiftUI view that simply displays a hardcoded list. Now let’s attempt to abstract the list items away into another object that is injected into the view. This object would be responsible for fetching our items and loading them for the view.\n\nThis is where an ObservableObject comes in.\n\n\n  When your type conforms to ObservableObject, you are creating a new source of truth and teaching SwiftUI how to react to changes. In other words, you are defining the data that a view needs to render its UI and perform its logic. SwiftUI uses this dependency to automatically keep your view consistent and show the correct representation of your data. We like to think of ObservableObject as your data dependency surface. This is the part of your model that exposes data to your view, but it’s not necessarily the full model.\n\n\nSo lets update our example to move our list of items into a separate class that conforms to this protocol.\n\nfinal class ListPresenter: ObservableObject {\n    @Published var listItems: [ListItemViewModel] = []\n}\n\n\nstruct ContentView: View {\n    @ObservedObject private var presenter: ListPresenter\n    \n    init(presenter: ListPresenter) {\n        self.presenter = presenter\n    }\n \n    var body: some View {\n        List(presenter.listItems) { item in\n            ListItemView(viewModel: item)\n        }\n    }\n}\n\nThe @Published property wrapper here works with the ObservableObject to notify SwiftUI whenever the value changes in order to trigger an update.\n\nWe also see the @ObservedObject property wrapper. This causes this view to subscribe to the ObservableObject that’s assigned to it, and invalidates the view any time the object updates.\n\nThis is great and allows us to inject an object from outside of the view who can manage the fetching and supplying to the view, whenever the listItems var updates, the view will automatically update!\n\nDe-coupling dependencies\n\nNow there is one problem here, can you see it? This view has a dependency between the view itself and the presenter class. Now if you are following the SOLID principles for example, and like to separate dependencies between your classes and layers we will need to remove the dependency between the view and presenter.\n\nTo do this lets change the ListPresenter class to be a protocol instead:\n\nfinal class ListPresenterImp: ListPresenter {\n    @Published var listItems: [ListItemViewModel] = []\n}\n\nprotocol ListPresenter: ObservableObject {\n    @Published var listItems: [ListItemViewModel] { get }\n}\n\nstruct ContentView: View {\n    @ObservedObject private var presenter: ListPresenter\n    \n    init(presenter: ListPresenter) {\n        self.presenter = presenter\n    }\n \n    var body: some View {\n        List(presenter.listItems) { item in\n            ListItemView(viewModel: item)\n        }\n    }\n}\n\nThis looks like it should be a straight forward change… Wrong! You will now start seeing errors galore. The primary cause coming from the decleration of our new protocol:\n\n\n  Property ‘listItems’ declared inside a protocol cannot have a wrapper\n\n\nThe problem here being exactly as the error states. We cannot use property wrappers inside protocols! That is going to cause a bit of a problem as we now can’t make use of the nice integration with SwiftUI via @Published properties, or so it seems…\n\nLet’s take a step back for a moment, what exactly does the @Published property wrapper actually do? The @Published property wrapper essentially provides a publisher that the SwiftUI system can subscribe to in order to listen to updates to the value. This is in fact an implementation detail. One of the key points of protocol oriented programming is to abstract the implementation of functions are variables away from the dependency so that it is unaware of the inner workings. By trying to apply a property wrapper to the protocol we are trying to enforce how that variable should implemented under the hood. When infact should the implementing class of our protocol wish to, they could create their own custom implementation of the wrapper.\n\nFixing the errors\n\nOk so let’s start by removing the @Published property wrapper from our protocol:\n\nfinal class ListPresenterImp: ListPresenter {\n    @Published var listItems: [ListItemViewModel] = []\n}\n\nprotocol ListPresenter: ObservableObject {\n    var listItems: [ListItemViewModel] { get }\n}\n\nstruct ContentView: View {\n    @ObservedObject private var presenter: ListPresenter\n    \n    init(presenter: ListPresenter) {\n        self.presenter = presenter\n    }\n \n    var body: some View {\n        List(presenter.listItems) { item in\n            ListItemView(viewModel: item)\n        }\n    }\n}\n\nGreat! However there are now a bunch of different errors occuring… The key one that we need to pay attention to is this one:\n\n\n  Protocol ‘ListPresenter’ can only be used as a generic constraint because it has Self or associated type requirements\n\n\nRight, so we have solved the riddle of @Published but this has now surfaced another problem. In order for our ListPresenter protocol to be compatible with the ObervedObject property wrapper in the view, it must extend ObservableObject. Now the problem here is that the ObservableObject uses an associatedtype. Which means if we wish to use it or hold a reference to it we must do type erasure (for more info read my previous post on type erasure) or use a generic constraint.\n\nThe simplest solution is for us to use a generic constraint on the view. View the code below:\n\nfinal class ListPresenterImp: ListPresenter {\n    @Published var listItems: [ListItemViewModel] = []\n}\n\nprotocol ListPresenter: ObservableObject {\n    var listItems: [ListItemViewModel] { get }\n}\n\nstruct ContentView&lt;T&gt;: View where T: ListPresenter {\n    @ObservedObject private var presenter: T\n    \n    init(presenter: T) {\n        self.presenter = presenter\n    }\n \n    var body: some View {\n        List(presenter.listItems) { item in\n            ListItemView(viewModel: item)\n        }\n    }\n}\n\nSo what has changed here. You will now notice that we have added a generic type T to our view. We have also added a generic constraint when implementing the View protocol which signals that the init and body implementations here are only when type T is a ListPresenter. Now in this instance that works fine as we only intend to use this view with our ListPresenter class. This removes the errors and the code now compiles. Let’s update the code and run a little test to make sure we are still getting all the reactive goodness of SwiftUI.\n\nfinal class ListPresenterImp: ListPresenter {\n    @Published var listItems: [ListItemViewModel] = []\n    \n    init() {\n        Timer.scheduledTimer(withTimeInterval: 5.0, repeats: false) { (timer) in\n            let items = [ListItemViewModel(id: 1, title: \"test\", subTitle: \"test sub\", image: \"first\"),\n                        ListItemViewModel(id: 2, title: \"test2\", subTitle: \"test sub1\", image: \"first\")]\n            \n            self.listItems = items\n        }\n    }\n}\n\nprotocol ListPresenter: ObservableObject {\n    var listItems: [ListItemViewModel] { get }\n}\n\nstruct ContentView&lt;T&gt;: View where T: ListPresenter {\n    @ObservedObject private var presenter: T\n    \n    init(presenter: T) {\n        self.presenter = presenter\n    }\n \n    var body: some View {\n        List(presenter.listItems) { item in\n            ListItemView(viewModel: item)\n        }\n    }\n}\n\nWe have updated our list presenter implementation class to update our list items after 5 seconds. Nice and easy. If we initialise our view with a presenter with 5 items as below, then after 5 seconds our list should reduce to the 2 items as set in the timer.\n\nlet items = [ListItemViewModel(id: 1, title: \"test\", subTitle: \"test sub\", image: \"first\"),\n                    ListItemViewModel(id: 2, title: \"test2\", subTitle: \"test sub1\", image: \"first\"),\n                    ListItemViewModel(id: 3, title: \"test3\", subTitle: \"test sub2\", image: \"first\"),\n                    ListItemViewModel(id: 4, title: \"test4\", subTitle: \"test sub3\", image: \"first\"),\n                    ListItemViewModel(id: 5, title: \"test5\", subTitle: \"test sub4\", image: \"first\")]\n        \nlet presenter = ListPresenterImp()\npresenter.listItems = items\nlet contentView = ContentView(presenter: presenter)\n\nNow let’s run this as part of an app and see what happens:\n\n\n\nSo as you can see, after 5 seconds the list of items is reduced after 5 seconds to 2 items, proving that our implementation works and we are still able to hook into the nice secret sauce that combine and swiftUI expose to us to allow us to update our views. I’ve seen some rather crazy implementations and workarounds on Stack Overflow. Hopefully this implementation is a little nicer!\n\nDownload the sample project to run it for yourself (Xcode 12.4)\n",
      tags: ["swift","combine","swiftui","architecture"],
      id: 1
    });
    

    index.add({
      title: "Repository Pattern in Swift",
      category: ["architecture"],
      content: "Background\n\nAll apps developed require data of some description. This data is stored somewhere, could be on the device itself, in a remote database/service or a combination. Let’s take a look at the most common sources of data:\n\n\n  JSON web services\n  UserDefaults\n  Core Data\n  Realm\n  Other 3rd party system\n\n\nEach of these methods saves data in a different format. Now I’m sure you will have used at least one of these methods in your apps at some point to retrieve / save data.\n\nWhen not using the repository pattern it is quite common to access and use these elements directly, either in your ViewController or in some other part of your app depending how it is structured.\n\nThe problem\n\nWhat’s the problem with this approach? Your app becomes difficult to maintain. Now if you only have a small app with a few screens then this isn’t much of a problem as there are only a few elements to change.\n\nHowever, what if you are working on a large app with several developers and lots of code? You could have NSManagedObjects or Codable objects littered throughout the codebase for example. What happens if you wish to remove Core Data? Perhaps move to realm? You would need to modify all of the classes in your codebase where you had used your Core Data objects.\n\nSimilarly, if you are using Codable objects directly from your JSON response. What happens when your backend team changes the API or you switch to a different API provider? The structure of the data may change which means your Codable objects might change. Again you will need to modify a large number of classes if you are working on a large app.\n\nWe can also apply this to the other options such as accessing data from 3rd party frameworks. If we use the objects returned from the framework directly, they will all need changing if we change provider or the SDK changes.\n\nThere is also the question of query language. Web services use headers and URLQueryItem, Core Data uses Predicates and so on. Every entry point to query the data must know and understand the underlying query language in order to get the information it once. Again, if this changes we need change every query point to the new format.\n\nLet’s have a look at the diagram below:\n\n\n\nHere we have an app structure that is making use of Core Data. There is an object that is being used to access the stack that returns some data. Let’s say for this example that it is news articles. These new articles must inherit from NSManagedObject to be used in Core Data. Now if our data layer is returning NSManagedObjects to the rest of our app structure we now have a dependency between Core Data and the rest of the files in our app. If we wish to move to Realm for example, or switch to using some other form of data store we would need to modify all the of files in the app. The app in this example is only small, imagine having to do that for a much bigger app!\n\nDomain Objects and the Repository\n\nThis is where Domain Objects come in. Domain Objects are value objects that are defined by your application. Rather than using objects and structures defined outside of the app, we define what we want the objects to look like. It’s then up to the repository to map between the data storage object / structure to these value objects.\n\nWhen we do this, it means any changes to the data access layer, as we discussed earlier such as data structure changes or changes in provider don’t impact the rest of the app. The only part of the app that needs to be updated is the repository and it’s mapping to the domain objects.\n\nThe below quote summarises the idea of the pattern:\n\n\n  Repositories are classes or components that encapsulate the logic required to access data sources. They centralize common data access functionality, providing better maintainability and decoupling the infrastructure or technology used to access databases from the domain model layer.\n\n\nLet’s have a look at our previous example but modified to use the a repository and domain objects:\n\n\n\nSo what is the difference here? As you can see the Core Data stack is still returning NSManagedObjects, however the repository is converting that to a domain object. This object doesn’t inherit from NSManagedObject, also it’s structure and attributes are defined by the app rather than what is in the data store.\n\nNow if we wanted to move away from Core Data to something else the only classes that need to be changed are the Core Data stack and the repository. The rest of the app does not need to be changed as we can map the new data stores type to our domain objects using the repository.\n\nExample\n\nTo show a small working example we are going to use a couple of Free Public APIs (highly recommend this resource if you are looking to build a demo app or experiment). We will use 2 APIs that returns users. However they return them in a different format.\n\nhttps://jsonplaceholder.typicode.com/users/1\n\nhttps://randomuser.me/api/\n\nAs we have done in previous blog posts we are going to use QuickType to generate our Codable objects from our JSON response. We will start with our first request.\n\n// MARK: - User\nstruct User: Codable {\n    let id: Int\n    let name, username, email: String\n    let address: Address\n    let phone, website: String\n    let company: Company\n}\n\n// MARK: - Address\nstruct Address: Codable {\n    let street, suite, city, zipcode: String\n    let geo: Geo\n}\n\n// MARK: - Geo\nstruct Geo: Codable {\n    let lat, lng: String\n}\n\n// MARK: - Company\nstruct Company: Codable {\n    let name, catchPhrase, bs: String\n}\n\nThis structure will allow us to decode the response from the first request. Let’s make a simple example that takes the response and outputs some data. We will be using code from our Simple JSON Decoder to process the output so feel free to read up if the code you see doesn’t make sense.\n\nlet url = URL(string: \"https://jsonplaceholder.typicode.com/users/1\")!\n// 1\nlet task = URLSession.shared.dataTask(with: url, completionHandler: { (user: User?, response, error) in\n\t// 2\n    if let error = error {\n        print(error.localizedDescription)\n        return\n    }\n\n    // 3\n    if let user = user {\n        print(user.name)\n        print(user.address.street)\n        print(user.address.city)\n        print(user.address.zipcode)\n        print(user.address.geo.lat)\n        print(user.address.geo.lng)\n    }\n})\ntask.resume()\n\nSo let’s step through what’s happening here:\n\n\n  First of all we are making the request using our Simple JSON Decoder to return our new User type.\n  Output any errors\n  So here we are outputting the name, address and location of the user we get back. Super simple right now.\n\n\nManaging change\n\nNow let’s say we change provider. Maybe our backend team changes the API, or we switch data provider or from 2 different data provider SDKs. In our example we will switch from the first url (https://jsonplaceholder.typicode.com/users/1) to the second (https://randomuser.me/api/).\n\nThe first thing we will need to do is change all of our codable objects as the structure of the response is different. Let’s use QuickType again to give us the new structure:\n\n// MARK: - Users\nstruct Users: Codable {\n    let results: [Result]\n    let info: Info\n}\n\n// MARK: - Info\nstruct Info: Codable {\n    let seed: String\n    let results, page: Int\n    let version: String\n}\n\n// MARK: - Result\nstruct Result: Codable {\n    let gender: String\n    let name: Name\n    let location: Location\n    let email: String\n    let login: Login\n    let dob, registered: Dob\n    let phone, cell: String\n    let id: ID\n    let picture: Picture\n    let nat: String\n}\n\n// MARK: - Dob\nstruct Dob: Codable {\n    let date: String\n    let age: Int\n}\n\n// MARK: - ID\nstruct ID: Codable {\n    let name: String\n    let value: String?\n}\n\n// MARK: - Location\nstruct Location: Codable {\n    let street: Street\n    let city, state, country: String\n    let postcode: Int\n    let coordinates: Coordinates\n    let timezone: Timezone\n}\n\n// MARK: - Coordinates\nstruct Coordinates: Codable {\n    let latitude, longitude: String\n}\n\n// MARK: - Street\nstruct Street: Codable {\n    let number: Int\n    let name: String\n}\n\n// MARK: - Timezone\nstruct Timezone: Codable {\n    let offset, timezoneDescription: String\n\n    enum CodingKeys: String, CodingKey {\n        case offset\n        case timezoneDescription = \"description\"\n    }\n}\n\n// MARK: - Login\nstruct Login: Codable {\n    let uuid, username, password, salt: String\n    let md5, sha1, sha256: String\n}\n\n// MARK: - Name\nstruct Name: Codable {\n    let title, first, last: String\n}\n\n// MARK: - Picture\nstruct Picture: Codable {\n    let large, medium, thumbnail: String\n}\n\nNow this is more complicated that it needs to be for our example but I’m leaving it here as an extreme example of how different things can be. As you can probably tell the structure and types have change dramatically from our first example. So let’s try and output the same data from this example in our previous example. We can ignore the request part and just focus on the data output so we can see the differences:\n\n// Request 1 output\nif let user = user {\n    print(user.name)\n    print(user.address.street)\n    print(user.address.city)\n    print(user.address.zipcode)\n    print(user.address.geo.lat)\n    print(user.address.geo.lng)\n}\n\n\n// Request 2 output\nif let user = users?.results.first {\n    print(\"\\(user.name.first) \\(user.name.last)\")\n    print(user.location.street.name)\n    print(user.location.city)\n    print(user.location.postcode)\n    print(user.location.coordinates.latitude)\n    print(user.location.coordinates.longitude)\n}\n\nAs you can see from even this simple example. We would have to change 7 lines of code, just to produce the same output. Now imagine this change happening on a much bigger project! There could possibly be 100s of lines of code that would need updating, all because the API response has changed.\n\nRepository Pattern\n\nHere is where the repository pattern comes in. We can create a user repository that fetches the user and converts it to our domain object. That way we don’t need to update the output.\n\nFirst thing to do is design our domain object that will represent a User in our system. Now all we are doing in this simple example is outputting a few attributes so let’s design our object with just those attributes as we don’t need the rest.\n\nstruct DomainUser {\n    let name: String\n    let street: String\n    let city: String\n    let postcode: String\n    let latitude: String\n    let longitude: String\n}\n\nHere we have a nice simple representation of our User object. There is no need to consider any of the other possible attributes returned from the API. We aren’t using them in our application and they will just sit around taking up valuable memory. You will also notice that this object doesn’t conform to Codable or subclass NSManagedObject. This is because DomainObject should not contain any knowledge about how they are stored. That is the responsibility of the repository.\n\nTo design our repository we can make use of Generics and Protocols to design a repository we can use for anything, not just our DomainUser. Let take a look:\n\nprotocol Repository {\n    associatedtype T\n    \n    func get(id: Int, completionHandler: (T?, Error?) -&gt; Void)\n    func list(completionHandler: ([T]?, Error?) -&gt; Void)\n    func add(_ item: T, completionHandler: (Error?) -&gt; Void)\n    func delete(_ item: T, completionHandler: (Error?) -&gt; Void)\n    func edit(_ item: T, completionHandler: (Error?) -&gt; Void)\n}\n\nprotocol CombineRepository {\n    associatedtype T\n    \n    func get(id: Int) -&gt; AnyPublisher&lt;T, Error&gt;\n    func list() -&gt; AnyPublisher&lt;[T], Error&gt;\n    func add(_ item: T) -&gt; AnyPublisher&lt;Void, Error&gt;\n    func delete(_ item: T) -&gt; AnyPublisher&lt;Void, Error&gt;\n    func edit(_ item: T) -&gt; AnyPublisher&lt;Void, Error&gt;\n}\n\nHere we have different functions for all of the operations we can do. What you will notice is that none of these functions specify where or how the data is stored. Remember when we talked about different storage options at the beginning? We could implement a repo that talks to an API (like in our example), one that stores things in Core Data or one that writes to UserDefaults. It’s up to the repository that implements the protocol to decide these details, all we care about is that we can load and save the data from somewhere.\n\nSee it action\n\nNow we have defined what the repository pattern is, let’s create 2 implementations. One for our first request and one for the second. Both should return domain objects, rather than the type returned from the request.\n\n// 1\nenum RepositoryError: Error {\n    case notFound\n}\n\nstruct FirstRequestImp: Repository {\n    typealias T = DomainUser\n    \n    // 2\n    func get(id: Int, completionHandler: @escaping (DomainUser?, Error?) -&gt; Void) {\n        let url = URL(string: \"https://jsonplaceholder.typicode.com/users/1\")!\n        let task = URLSession.shared.dataTask(with: url, completionHandler: { (user: User?, response, error) in\n            if let error = error {\n                completionHandler(nil, error)\n                return\n            }\n\n            guard let user = user else {\n                completionHandler(nil, RepositoryError.notFound)\n                return\n            }\n            \n            // 3\n            let domainUser = DomainUser(\n                name: user.name,\n                street: user.address.street,\n                city: user.address.city,\n                postcode: user.address.zipcode,\n                latitude: user.address.geo.lat,\n                longitude: user.address.geo.lng\n            )\n            \n            completionHandler(domainUser, nil)\n        })\n        task.resume()\n    }\n    \n     // 4\n    func list(completionHandler: @escaping ([DomainUser]?, Error?) -&gt; Void) {}\n    func add(_ item: DomainUser, completionHandler: @escaping (Error?) -&gt; Void) {}\n    func delete(_ item: DomainUser, completionHandler: @escaping (Error?) -&gt; Void) {}\n    func edit(_ item: DomainUser, completionHandler: @escaping (Error?) -&gt; Void) {}\n}\n\nstruct SecondRequestImp: Repository {\n    typealias T = DomainUser\n    \n    func get(id: Int, completionHandler: @escaping (DomainUser?, Error?) -&gt; Void) {\n        let url = URL(string: \"https://randomuser.me/api/\")!\n        let task = URLSession.shared.dataTask(with: url, completionHandler: { (users: Users?, response, error) in\n            if let error = error {\n                completionHandler(nil, error)\n                return\n            }\n\n            guard let user = users?.results.first else {\n                completionHandler(nil, RepositoryError.notFound)\n                return\n            }\n            \n            // 5\n            let domainUser = DomainUser(\n                name: \"\\(user.name.first) \\(user.name.last)\",\n                street: user.location.street.name,\n                city: user.location.city,\n                postcode: \"\\(user.location.postcode)\",\n                latitude: user.location.coordinates.latitude,\n                longitude: user.location.coordinates.longitude\n            )\n            \n            completionHandler(domainUser, nil)\n        })\n        task.resume()\n    }\n    \n    func list(completionHandler: @escaping ([DomainUser]?, Error?) -&gt; Void) {}\n    func add(_ item: DomainUser, completionHandler: @escaping (Error?) -&gt; Void) {}\n    func delete(_ item: DomainUser, completionHandler: @escaping (Error?) -&gt; Void) {}\n    func edit(_ item: DomainUser, completionHandler: @escaping (Error?) -&gt; Void) {}\n}\n\nThere’s quite a bit of code here so let’s step through it.\n\n\n  First of all we have defined a new error to send back if we don’t receive any user info from the API.\n  This is the same call we made in our example before.\n  Now here we are taking the returned Codable User and converting it to your new DomainUser class.\n  We aren’t implementing the other functions in this example so just leaving them empty for now to remove errors.\n  This struct is the second request we are making, and again here we are mapping our Users Codable type from the second request to our DomainUser.\n\n\nNow that we have made our two repositories, let’s show how we can quickly switch between them without breaking / changing code.\n\nlet repository: FirstRequestImp = FirstRequestImp()\nrepository.get(id: 1) { (user, error) in\n    if let error = error {\n        print(error)\n    }\n    \n    if let user = user {\n        print(user.name)\n        print(user.street)\n        print(user.city)\n        print(user.postcode)\n        print(user.latitude)\n        print(user.longitude)\n    }\n}\n\nHere is our example from earlier in the article but updated to use our new repositories. Here we go and fetch the user and print their details, the same as before. Now below we can switch to our second request and see how that will work.\n\nlet repository: SecondRequestImp = SecondRequestImp()\nrepository.get(id: 1) { (user, error) in\n    if let error = error {\n        print(error)\n    }\n    \n    if let user = user {\n        print(user.name)\n        print(user.street)\n        print(user.city)\n        print(user.postcode)\n        print(user.latitude)\n        print(user.longitude)\n    }\n}\n\nNow notice how the only part we changed was the implementation class? The rest of the code remained the same even though where the data was coming from has changed and is coming back in a completely different structure. Now imagine we are using this repo in many places to fetch user details. We can quickly switch between different data sources without changing the code that uses it. The only changes we have to make are to the repo and to the data mapping code. So only one change rather than a change in every single class that uses these objects.\n\nConclusion\n\nSo let’s recap what we have discussed here:\n\n\n  First of all we discussed the problem of using data storage classes throughout your codebase. Especially on large projects if you need to switch data source / structure.\n  We then discussed how using the repository pattern and mapping to domain objects rather than using data storage classes can make your code easier to change in the future.\n  We worked through some examples of how changing API structures can impact your code.\n  We then implemented a basic repository pattern with mapping to domain objects to show how doing this can make updating your project easier.\n\n\nFinally let’s discuss the pros and cons of the approach:\n\nAdvantages\n\n\n  Code is easier to change if you need to switch data source or structure\n  Separates concerns of where / how data is stored away from the rest of your app\n\n\nDisadvantages\n\n\n  Adds more code and complexity\n  Need to write mappers for each object to domain objects\n  Not really needed on smaller solo projects\n\n\nFeel free to download the playground and play around with the examples yourself\n",
      tags: ["swift","combine","generics","architecture"],
      id: 2
    });
    

    index.add({
      title: "Simple offline caching in Swift and Combine",
      category: ["networking"],
      content: "Background\n\nFollowing on from the previous post where we explored simple JSON decoding. In this post we are going to extend that simple networking example to include some offline caching so that if our network requests fail we can still provide content.\n\nI hear of a lot of people put off by providing a caching layer in their apps for data. Popular solutions include putting an actual relational database inside your app to cache the data such as using Core Data or Realm. Now these solutions are fine if you are intending to levarage the power of a relational database to perform some kind of task. However they add a lot more complexity if you are simply using them as a caching layer. A few draw backs below:\n\n\n  If you are consuming in an house API you may be trying to replicate a back end database structure driven by a much more capable server side DBMS.\n  Whether you are mapping against a back end database or just the returned JSON. What happens when the structure changes? Do you need to update your parsing and data structure. Do you need to migrate data?\n  Not only do you need to make sure you can parse and store the data correctly, you then must make sure you query the data in the same way so that you get the same results as returned from the API.\n  What happens if multiple requests need to update the data? Handling concurrent data updates carries it’s own complexity and head aches.\n\n\nThis is just a sample of the challenges faced when trying to use a relational database as a caching layer for your app. Now you could build some custom caching layer that writes things to disk or a library such as PINCache. However what if I told you there is something simpler that is already built in to iOS as standard?\n\nCaching Headers\n\nTo help explain this we need to explore how HTTP caching headers are intended to work. Now, most request to an API will return a bunch of HTTP headers. These provide information and advice to the receiver about the response to the request. We won’t cover them all but the one we are most interested in for this example is the Cache-Control header.\n\n\n  Cache-control is an HTTP header used to specify browser caching policies in both client requests and server responses. Policies include how a resource is cached, where it’s cached and its maximum age before expiring (i.e., time to live)\n\n\nThe part of this statement that talks about maximum age before expiring is what we will explore here. Most APIs will specify something called a max-age in the response headers. This is the length of time in seconds that the receiver should consider this information valid for. After that period of time the response should be considered stale and new data be fetched from the source.\n\nBy default URLSession and URLRequest have a cache policy of useProtocolCachePolicy. This means they will honour the HTTP caching headers when making requests. In the case of the above it will cache request responses for the time specified in the header. It is possible to override this behaviour if you wish using one of the other options.\n\nPostman\n\nTo demonstrate this behaviour in action we are going to use a tool called Postman. You may be using this already, it’s a fantastic tool for developing and testing APIs. One of the services that are provided by Postman is something called Postman Echo. This is a service that allows you to send various URL parameters to it and have postman reply those items back to you in a certain response format. To test our example we are going to use the response headers service that is provided, this allows us to specify headers and values in the url query string and have them played back to us in the actual response headers.\n\nIf we hit the URL below, you will get a response with the specified headers that you send in the URL query params.\n\nhttps://postman-echo.com/response-headers?Cache-Control=max-age=30\n\nWe get back a header in the response of Cache-Control: max-age=30. This means that anyone processing the response should cache the response for 30 seconds at the most before requesting fresh data, as discussed previously.\n\nWe can use this to prove how the caching works in URLSession.\n\nCaching in URLSession\n\nLet’s setup an example below on how to test out these cache headers:\n\n// 1\nlet url = URL(string: \"https://postman-echo.com/response-headers?Content-Type=text/html&amp;Cache-Control=max-age=30\")!\nlet request = URLRequest(url: url)\n\nlet task = URLSession.shared.dataTask(with: url) { (data, response, error) in\n\t// 2\n    if let httpResponse = response as? HTTPURLResponse,\n        let date = httpResponse.value(forHTTPHeaderField: \"Date\"),\n        let cacheControl = httpResponse.value(forHTTPHeaderField: \"Cache-Control\") {\n\n        // 3\n        print(\"Request1 date: \\(date)\")\n        print(\"Request1 Cache Header: \\(cacheControl)\")\n    }\n}\ntask.resume()\n\n// 4\nsleep(5)\n\n// 5\nlet task2 = URLSession.shared.dataTask(with: url) { (data , response, error) in\n    if let httpResponse = response as? HTTPURLResponse,\n        let date = httpResponse.value(forHTTPHeaderField: \"Date\"),\n        let cacheControl = httpResponse.value(forHTTPHeaderField: \"Cache-Control\") {\n\n        print(\"Request2 date: \\(date)\")\n        print(\"Request2 Cache Header: \\(cacheControl)\")\n    }\n}\ntask2.resume()\n\nLet’s step through this example step by step to demonstrate what is happening:\n\n\n  First of all we setup our postman echo request, we will set this up to return cache headers of 30 seconds\n  We make a request using the standard dataTask method. When we get the response we cast it to an HTTPURLResponse. An HTTPURLResponse contains a dictionary called allHeaders which is a dictionary containing all of the headers returned in the response. However this is error prone as dictionary keys are case sensitive. To combat this Apple have added a new function called value that takes a key string but does a case-insensitive match against the header so you don’t have to.\n  With the code in point 2 we are grabbing the date of the response and the cache control header and printing them to the console so we can see what they are.\n  We sleep for 5 seconds then perform another request.\n  Here are performing the same request as above and fetching the values of the response headers again. This will help us to see how the caching works.\n\n\nIf we run the above code in our playground we should see the following in the console:\n\nRequest1 date: Tue, 23 Jun 2020 09:21:36 GMT\nRequest1 Cache Header: max-age=30\nRequest2 date: Tue, 23 Jun 2020 09:21:36 GMT\nRequest2 Cache Header: max-age=30\n\n\nSo what does this tell us about our requests?\n\n\n  The first 2 lines show that our request executed at a certain date and time, the second line displays the cache header we configured in our postman echo request.\n  The last 2 lines show the same thing?\n\n\nThis is because we set a cache time of 30 seconds in the request header. As you know from step 4 above, we slept for 5 seconds inbetween each request. The fact the date headers are the same shows that the second request response is in fact the same response as the first request, it has just been fetched from the cache.\n\nTo prove this we can modify the request so that we only cache the response for 3 seconds, this way when we sleep for 5 seconds, the response from the first request should be considered stale and the second request should end up with a new response.\n\nLet’s modify the URL in our request to set the cache control to 3:\n\nhttps://postman-echo.com/response-headers?Cache-Control=max-age=3\n\nNow if we run the example above the console messages should look something like this:\n\nRequest1 date: Tue, 23 Jun 2020 11:34:58 GMT\nRequest1 Cache Header: max-age=3\nRequest2 date: Tue, 23 Jun 2020 11:35:03 GMT\nRequest2 Cache Header: max-age=3\n\n\nHow is this different from above. The main difference you will notice is that the request times are now different. The second request timestamp is 5 seconds after the first. This is because our cache time is 3 seconds now, so the second request is no longer pulling from the cache and is in fact a new request with a new response.\n\nOffline and the Network Conditioner\n\nNow you are probably asking yourself what this has to do with offline caching? To understand how we can leverage this caching behaviour we need to throttle our requests so that they fail. One of the tools at our disposal is something called the Network Conditioner. This is provided by Apple in the additional tools download.\n\nIf you download the tools and install the network conditioner preference pane, you should be able to launch it from your Mac preferences. Once open you should see something like the below:\n\n\n\nThis tool allows you to create various network conditions on your mac, such as 100% packet loss, 3G, dial up etc. We are going to use this to replicate a connection failure in our example to see how we can begin to use some of URLSession’s properties to access cached request data.\n\nIf we add the below into our second request callback so we can see if the request errors:\n\nif let error = error {\n    print(error.localizedDescription)\n}\n\nIf we run the sample again, however this time once we receive the first 2 console messages. We activate the network conditioner using 100% loss. This will cause the second request to fail (it may take a few seconds for the request to timeout).\n\nIf done correctly we should see something like below in the console:\n\nRequest1 date: Tue, 23 Jun 2020 12:36:09 GMT\nRequest1 Cache Header: max-age=3\nThe request timed out.\n\n\nNow we aren’t getting a response from the second request. Instead we are receiving an error. This is expected behaviour as the second request is indeed failing. What we can do in this scenario is grab the response from the cache if we so wish. To do so add the code below to the second completion handler:\n\nif let cachedResponse = URLSession.shared.configuration.urlCache?.cachedResponse(for: request),\n    let httpResponse = cachedResponse.response as? HTTPURLResponse,\n    let date = httpResponse.value(forHTTPHeaderField: \"Date\") {\n\n    print(\"cached: \\(date)\")\n}\n\nPart of the URLSession is the URLSessionConfiguration. This is an object which provides all of the configuration for the URLSession. One of the attributes here is the URLCache. This is where the magic happens. It is an in-memory and on-disk cache of the responses from URLRequests. It is responsible for storing and deleting the data, in our example that is controlled via the response headers.\n\nOne of the methods on the URLCache is cachedResponse. This will return the cached response for any URL request still in the cache.\n\nIn the example above we are pulling the cached response and outputting the header of the attached HTTPURLResponse. If we take another look at our example with the additional 2 snippets above we should have something like below:\n\nlet url = URL(string: \"https://postman-echo.com/response-headers?Content-Type=text/html&amp;Cache-Control=max-age=3\")!\nlet request = URLRequest(url: url)\nlet task = URLSession.shared.dataTask(with: url) { (data, response, error) in\n    if let httpResponse = response as? HTTPURLResponse,\n        let date = httpResponse.value(forHTTPHeaderField: \"Date\"),\n        let cacheControl = httpResponse.value(forHTTPHeaderField: \"Cache-Control\") {\n\n        print(\"Request1 date: \\(date)\")\n        print(\"Request1 Cache Header: \\(cacheControl)\")\n    }\n}\ntask.resume()\n\nsleep(5)\n\nlet task2 = URLSession.shared.dataTask(with: url) { (data , response, error) in\n    if let httpResponse = response as? HTTPURLResponse,\n        let date = httpResponse.value(forHTTPHeaderField: \"Date\"),\n        let cacheControl = httpResponse.value(forHTTPHeaderField: \"Cache-Control\") {\n\n        print(\"Request2 date: \\(date)\")\n        print(\"Request2 Cache Header: \\(cacheControl)\")\n    }\n\n    if let error = error {\n        print(error.localizedDescription)\n\n        if let cachedResponse = URLSession.shared.configuration.urlCache?.cachedResponse(for: request),\n            let httpResponse = cachedResponse.response as? HTTPURLResponse,\n            let date = httpResponse.value(forHTTPHeaderField: \"Date\") {\n\n            print(\"cached: \\(date)\")\n        }\n    }\n}\ntask2.resume()\n\nNow if we follow the same test as before:\n\n\n  Run the playground\n  Wait for first request to finish\n  Activate network conditioner with 100% packet loss\n\n\nWhat we should see in the console is this:\n\nRequest1 date: Sun, 28 Jun 2020 07:03:48 GMT\nRequest1 Cache Header: max-age=3\nThe request timed out.\ncached: Sun, 28 Jun 2020 07:03:48 GMT\n\n\nSo what is happening here?\n\n\n  The first request is completing successfully so we can see the date and cache header info. The same as before.\n  The seconds request is failing, hence the request timeout error\n  However this time, as the request has failed we are fetching the previously made request response from the cache and outputting the header from that.\n\n\nNow that we have shown how to grab cached requests from the cache, let’s wrap this up in a nice way so we can reuse it if we wish\n\nWrapping it up\n\nFirst of all lets create a standard swift example, then we will have a look at how we can do this in Combine and some of the challenges in doing so.\n\nextension URLSession {\n    // 1\n    func dataTask(with url: URL,\n                  cachedResponseOnError: Bool,\n                  completionHandler: @escaping (Data?, URLResponse?, Error?) -&gt; Void) -&gt; URLSessionDataTask {\n\n        return self.dataTask(with: url) { (data, response, error) in\n            // 2\n            if cachedResponseOnError,\n                let error = error,\n                let cachedResponse = self.configuration.urlCache?.cachedResponse(for: URLRequest(url: url)) {\n\n                completionHandler(cachedResponse.data, cachedResponse.response, error)\n                return\n            }\n\n            // 3\n            completionHandler(data, response, error)\n        }\n    }\n}\n\nSo let’s walk through what we are doing here:\n\n\n  We have created a method the same as the standard dataTask method on URLSession. However we have added a bool to control whether we would like to return the cached response on receiving a network error.\n  Here we take the example we used earlier in our example and applied it to this method. First we check whether we should return the cached response based on our cachedResponseOnError parameter. Then check to see if we do have an error, if we do then attempt to grab the cached response from the URLCache and return it’s data and response objects along with the error.\n  In the case where any of the above fails we simply return everything exactly as it was in returned by the normal dataTask method.\n\n\nAs the completion handler returns Data, URLResponse and Error we are able to return the data and response even if there is an error. That is a bit of a disadvantage in this case as the function caller needs to be aware that they may receive an error but also the cached response as well so need to cater for those scenario themselves.\n\nCombine\n\nHopefully you have at least heard of Combine even if you haven’t had chance to use it yet in a production app. It is Apple’s own version of a reactive framework. Those of you who have already been using RxSwift will be right at home. We aren’t going to go into too much detail about what Combine is but here is a definition of what reactive programming is:\n\n\n  In computing, reactive programming is a declarative programming paradigm concerned with data streams and the propagation of change\n\n\nIn more simplistic terms, reactive programming uses a observer pattern to allow classes to monitor different streams of data or state. When this state changes it emits an event with the new value which can trigger other streams to perform work or update such as UI code. If you are familier with KVO you will understand the basic concept. However reactive programming is far less painful and a lot more powerful than KVO.\n\nNow the approach described in the previous section works fine in the case of the completionHandler as it allows us to return all 3 items to the caller regardless of what happens. However in combine streams are designed to either return a value OR an error.\n\nFirst of all let’s look at a simple example:\n\n// 1\ntypealias ShortOutput = URLSession.DataTaskPublisher.Output\n\nextension URLSession {\n    // 2\n    func dataTaskPublisher(for url: URL,\n                           cachedResponseOnError: Bool) -&gt; AnyPublisher&lt;ShortOutput, Error&gt; {\n\n        return self.dataTaskPublisher(for: url)\n            // 3\n            .tryCatch { [weak self] (error) -&gt; AnyPublisher&lt;ShortOutput, Never&gt; in\n                // 4\n                guard cachedResponseOnError,\n                    let urlCache = self?.configuration.urlCache,\n                    let cachedResponse = urlCache.cachedResponse(for: URLRequest(url: url)) \n                else {\n                    throw error\n                }\n\n                // 5\n                return Just(ShortOutput(\n                    data: cachedResponse.data,\n                    response: cachedResponse.response\n                )).eraseToAnyPublisher()\n        // 6\n        }.eraseToAnyPublisher()\n    }\n}\n\nSo let’s step through what is happening here:\n\n\n  First I am creating a typealias of the dataTaskPublisher.Output. This is mostly for code formatting reasons as the string is very long. This is simply a Data object and a URLResponse object in a tuple.\n  Here we have setup our function with the cachedResponseOnError flag the same as before. We are returning a publisher with our type aliased output.\n  First we call the standard dataTaskPublisher method to setup our request. We immediately chain that publisher using the new tryCatch. So what does this do? “Handles errors from an upstream publisher by either replacing it with another publisher or throwing a new error.” So here we catch any connection errors from the dataTaskPublisher and we can either throw another error or send another publisher down the chain.\n  So the same as our pure Swift example we attempt to fetch our response from the cache, except here if we fail to find anything in the cache we just rethrow the same error we received in the try catch block so it can be handled further down the stream.\n  If we were able to find a response in the cache then we use the Just publisher to send the new value down the stream wrapping our cached response.\n  We erase the types to AnyPublisher using type erasure so items further down the stream don’t need to know the types. For more info on type erasure see my previous post.\n\n\nNow let’s take our previous test and adapt it so we can see this in action:\n\n// 1\nlet url = URL(string: \"https://postman-echo.com/response-headers?Content-Type=text/html&amp;Cache-Control=max-age=3\")!\nlet publisher = URLSession.shared.dataTaskPublisher(for: url, cachedResponseOnError: true)\n\n// 2\nlet token = publisher\n    .sink(receiveCompletion: { (completion) in\n        switch completion {\n        case .finished:\n            break\n        case .failure(let error):\n            print(error.localizedDescription)\n        }\n    }) { (responseHandler: URLSession.DataTaskPublisher.Output) in\n        if let httpResponse = responseHandler.response as? HTTPURLResponse,\n            let date = httpResponse.value(forHTTPHeaderField: \"Date\"),\n            let cacheControl = httpResponse.value(forHTTPHeaderField: \"Cache-Control\") {\n\n            print(\"Request1 date: \\(date)\")\n            print(\"Request1 Cache Header: \\(cacheControl)\")\n        }\n    }\n\n// 3\nsleep(5)\n\n// 4\nlet token2 = publisher\n    .sink(receiveCompletion: { (completion) in\n        switch completion {\n        case .finished:\n            break\n        case .failure(let error):\n            print(error.localizedDescription)\n        }\n    }) { (responseHandler: URLSession.DataTaskPublisher.Output) in\n        if let httpResponse = responseHandler.response as? HTTPURLResponse,\n            let date = httpResponse.value(forHTTPHeaderField: \"Date\"),\n            let cacheControl = httpResponse.value(forHTTPHeaderField: \"Cache-Control\") {\n\n            print(\"Request2 date: \\(date)\")\n            print(\"Request2 Cache Header: \\(cacheControl)\")\n        }\n    }\n\nAs we have done with our other examples let’s step through and see what happens.\n\n\n  First we create our request as we did in the pure Swift example, and then create our new publisher using our newly created function.\n  Now in Combine, publisher’s only execute once there is an unsatisfied subscription. This happens whenever the sink function is called. The first closure is called when either the stream completes or an error throws (which also terminates the stream). The second closure is called whenever a new value is published from the stream. In this first case we can a tuple containing Data and a URLResponse. As before we inspect the date header of the request.\n  As before we sleep for 5 seconds (we have set a timeout of 3 on using the cache control headers)\n  This matches the same as step 2 however we changed the output.\n\n\nIf we follow the same steps as before and turn on packet loss using the network conditioner when we hit step 3 we should see a console log like below:\n\nRequest1 date: Tue, 30 Jun 2020 07:53:26 GMT\nRequest1 Cache Header: max-age=3\nRequest2 date: Tue, 30 Jun 2020 07:53:26 GMT\nRequest2 Cache Header: max-age=3\n\n\nNow, this proves that we are returning our cached response in the second request as we have no connection and we are still receiving a response. However what is the problem here?\n\nThere is no error\n\nThe above implementation works fine if we just want to display cached data. However you may wish to inform the user that there was a connection failure and they are viewing old / stale information. So how can we get around this? In order to send the cached value, then the error we would need to create a custom Combine publisher. We won’t cover that here as that is a post in itself.\n\nConclusion\n\nWe have shown how we can make use of built in functionality of URLSession and URLCache along with the HTTP standard headers to provide simple and basic offline caching.\n\nAdvantages\n\n\n  Simple implementation, doesn’t require 3rd party frameworks or complex relational databases\n  Makes use of 1st party frameworks and relies on currently available standards (HTTP)\n  Concurrency handled automatically\n\n\nDisadvantages\n\n\n  Relies on cache-control headers being correctly used in the API being consumed\n  URLSession cache policies need to be configured correctly\n  Doesn’t support more complex caching requirements / rules if needed\n  URLCache will delete the cache if device memory becomes full, something to bear in mind using this approach\n\n\nIn summary, this approach is simple and provides basic offline functionality for your app. If you have more complex needs / requirements for caching your data then other approaches may be more suitable.\n\nFeel free to download the playground and play around with the examples yourself\n",
      tags: ["swift","combine","generics","networking","caching"],
      id: 3
    });
    

    index.add({
      title: "Simple JSON decoder in Swift and Combine",
      category: ["networking"],
      content: "Intro\n\nPretty much every app nowadays requires you to connect to the internet to access some content. The majority of those apps use JSON to communicate that data from the backend systems.\n\nThere is high chance you will have some code in your app to download, parse and return objects for your app to use from an endpoint (unless you are using a network library such as Alamofire)\n\nIn this post we are going to demonstrate how we can use Generics and Codable to help us build a simple reusable JSON decoder to download and parse responses from our endpoints.\n\nBuilding our codable objects\n\nThe first thing we need to do is build our codable objects. Objects that implement the Codable protocol allow Encoders and Decoders to encode or decode them to and from an external representation such as JSON.\n\nLet’s take the response from the sample endpoint below as an example:\n\nhttps://jsonplaceholder.typicode.com/users\n\n{\n    \"id\": 1,\n    \"name\": \"Leanne Graham\",\n    \"username\": \"Bret\",\n    \"email\": \"Sincere@april.biz\",\n    \"address\": {\n      \"street\": \"Kulas Light\",\n      \"suite\": \"Apt. 556\",\n      \"city\": \"Gwenborough\",\n      \"zipcode\": \"92998-3874\",\n      \"geo\": {\n        \"lat\": \"-37.3159\",\n        \"lng\": \"81.1496\"\n      }\n    },\n    \"phone\": \"1-770-736-8031 x56442\",\n    \"website\": \"hildegard.org\",\n    \"company\": {\n      \"name\": \"Romaguera-Crona\",\n      \"catchPhrase\": \"Multi-layered client-server neural-net\",\n      \"bs\": \"harness real-time e-markets\"\n    }\n  }\n\nYou can create codable classes yourself by hand. In simple examples this can be fairly straight forward, however if you have a response that has a more complex structure, doing so can be time consuming and error prone.\n\nTo create our codable objects we can use a generator, my weapon of choice is QuickType. We just paste in the JSON that is returned from the posts endpoint and it automatically generates the Codable structs for us. Easy!\n\nIf we paste in our post response, we should end up with some code looking like this:\n\n// MARK: - User\nstruct User: Codable {\n    let id: Int\n    let name, username, email: String\n    let address: Address\n    let phone, website: String\n    let company: Company\n}\n\n// MARK: - Address\nstruct Address: Codable {\n    let street, suite, city, zipcode: String\n    let geo: Geo\n}\n\n// MARK: - Geo\nstruct Geo: Codable {\n    let lat, lng: String\n}\n\n// MARK: - Company\nstruct Company: Codable {\n    let name, catchPhrase, bs: String\n}\n\ntypealias Users = [User]\n\nHow easy was that?! Obviously we will still need to check the structs, in the example above none of the fields are optional which means data must be passed in otherwise our decoding will fail. We don’t need to worry about that here, but worth remembering when checking the generated code in your examples.\n\nURLSession extension and Generics\n\nTo solve our problem we are going to wrap the existing URLSession dataTask method. I’m sure if you have done any kind of request work in pure swift you will have used this method in some form so we aren’t going to go into the details of how it works.\n\nextension URLSession {\n\n\t// 1\n    enum SessionError: Error {\n        case noData\n        case statusCode\n    }\n\n    /// Wraps the standard dataTask method with a JSON decode attempt using the passed generic type.\n    /// Throws an error if decoding fails\n    /// - Parameters:\n    ///   - url: The URL to be retrieved.\n    ///   - completionHandler: The completion handler to be called once decoding is complete / fails\n    /// - Returns: The new session data task\n\n    // 2 \n    func dataTask&lt;T: Decodable&gt;(with url: URL,\n                                completionHandler: @escaping (T?, URLResponse?, Error?) -&gt; Void) -&gt; URLSessionDataTask {\n\n        // 3\n        return self.dataTask(with: url) { (data, response, error) in\n        \t// 4\n            guard error == nil else {\n                completionHandler(nil, response, error)\n                return\n            }\n\n            // 5\n            if let response = response as? HTTPURLResponse,\n                (200..&lt;300).contains(response.statusCode) == false {\n                completionHandler(nil, response, SessionError.statusCode)\n            }\n\n            // 6\n            guard let data = data else {\n                completionHandler(nil, response, SessionError.noData)\n                return\n            }\n\n            // 7\n            do {\n                let decoded = try JSONDecoder().decode(T.self, from: data)\n                completionHandler(decoded, response, nil)\n            } catch(let error) {\n                completionHandler(nil, response, error)\n            }\n        }\n    }\n}\n\nSo let’s step through this code sample step by step:\n\n\n  First of we have defined a custom error for this extension, this is returned when no data has been returned from the request, covered in point 6. We also have an error case if we get an HTTPURLResponse with an incorrect status code, covered in point 5.\n  Here we are making use of Generics to allow any type T being returned from this function as long as type T implements the Decodable protocol (which we need it to inorder to use the JSONDecoder)\n  As discussed, here we are calling the existing dataTask method to run our request.\n  First thing we do once the request has returned is check to see if there was a request error, if so we call the completion handler with the response and the error.\n  The second check we perform is to check the status code if we have received an HTTPURLResponse. Note we aren’t stopping the code here if we don’t get a HTTPURLResponse as you could use this function to load a local JSON file for example, not just a remote URL. Any status code in the 200-299 range is considered a successful request, if we receive a status code outside this range we return an error along with the response for further processing by whoever passed the completion handler.\n  The third check we perform is to unwrap data ready for decoding. If this fails (as in it’s nil) then we call the completionHandler with the response and our custom error defined in step 1.\n  The final piece of the puzzle is to attempt to decode the data into type T we defined in the method signature as part of step 2. If this succeeds we can call our completion handler with our decoded type and response. If it throws an error we capture the error and return it using the catch block below.\n\n\nSee it in action\n\nNow that we have put our function together, let’s take it for a test drive.\n\nlet url = URL(string: \"https://jsonplaceholder.typicode.com/users\")!\nlet task = URLSession.shared.dataTask(with: url, completionHandler: { (users: Users?, response, error) in\n    if let error = error {\n        print(error.localizedDescription)\n        return\n    }\n\n    users?.forEach({ print(\"\\($0.name)\\n\") })\n})\ntask.resume()\n\nThis shouldn’t look too scarey, infact if you have used the standard dataTask functions in your code previously this should look very familiar. The only different here being that our completion handler now returns our Codable User objects rather than just a blob of Data like before.\n\nHopefully that example makes sense and gives you a nice simple way to perform a request and have it decode some JSON into a struct / class. Now let’s have a look at some reactive programming using Combine.\n\nCombine\n\nHopefully you have at least heard of Combine even if you haven’t had chance to use it yet in a production app. It is Apple’s own version of a reactive framework. Those of you who have already been using RxSwift will be right at home. We aren’t going to go into too much detail about what Combine is but here is a definition of what reactive programming is:\n\n\n  In computing, reactive programming is a declarative programming paradigm concerned with data streams and the propagation of change\n\n\nIn more simplistic terms, reactive programming uses a observer pattern to allow classes to monitor different streams of data or state. When this state changes it emits an event with the new value which can trigger other streams to perform work or update such as UI code. If you are familier with KVO you will understand the basic concept. However reactive programming is far less painful and a lot more powerful than KVO.\n\nNow let’s take the previous pure Swift example and see how we can use it in Combine. The Combine framework adds new reactive functionality to the URLSession in the form of the dataTaskPublisher function.\n\nextension URLSession {\n\n\t// 1\n    enum SessionError: Error {\n        case statusCode(HTTPURLResponse)\n    }\n\n    /// Function that wraps the existing dataTaskPublisher method and attempts to decode the result and publish it\n    /// - Parameter url: The URL to be retrieved.\n    /// - Returns: Publisher that sends a DecodedResult if the response can be decoded correctly.\n\n    // 2\n    func dataTaskPublisher&lt;T: Decodable&gt;(for url: URL) -&gt; AnyPublisher&lt;T, Error&gt; {\n    \t// 3\n        return self.dataTaskPublisher(for: url)\n        \t// 4\n            .tryMap({ (data, response) -&gt; Data in\n                if let response = response as? HTTPURLResponse,\n                    (200..&lt;300).contains(response.statusCode) == false {\n                    throw SessionError.statusCode(response)\n                }\n\n                return data\n            })\n            // 5\n            .decode(type: T.self, decoder: JSONDecoder())\n            // 6\n            .eraseToAnyPublisher()\n    }\n}\n\nSimilar to our previous example we have extended URLSession to provide this functionality. Let’s step through it:\n\n\n  As with the pure Swift example we are defining a custom error here to handle when we receive a status code that is not a success. The difference being here we are attaching the response to the error as we don’t have a completionHandler in Combine. That way whoever is handling the error can inspect the response and see why it failed.\n  Here we are defining the method, again using generics to only accept a type T that has implemented the  Decodable protocol. The function returns a publisher who returns our decoded object.\n  As discussed previously, we are simply wrapping the existing dataTaskPublisher method.\n  Now here is where things start to become reactive. The tryMap function is similar to the standard map function in that it attempts to convert / transfrom elements from one type to another. However the difference here being that it is almost wrapped in a try. In this case you can include code in the closure which throws errors and they will be pushed downstream and handled later instead of needing a do block. Similar to our pure Swift example, we are checking we have a valid status code, if not we throw our custom error. If not we map our data ready to be decoded.\n  Here we are using the built in decode method to attempt to decode our custom type using the JSONDecoder. Similar to the tryMap function above, any errors are pushed downstream to be handler later.\n  The final piece of the puzzle is to use type erasure. This removes the publisher class type and makes it AnyPublisher. For more info on type erasure see my previous post\n\n\nCombine in action\n\nNow that we have built our wrapper class let’s take a look at this in action:\n\nlet url = URL(string: \"https://jsonplaceholder.typicode.com/users\")!\n\nlet token = URLSession.shared.dataTaskPublisher(for: url)\n\t// 1\n    .sink(receiveCompletion: { (completion) in\n        switch completion {\n        // 2\n        case .finished:\n            break\n        case .failure(let error):\n            print(error.localizedDescription)\n        }\n    }) { (users: Users) in\n    \t// 3\n        users.forEach({ print(\"\\($0.name)\\n\") })\n    }\n\n\n  Here we have called our newly created dataTaskPublisher method which has returned our publisher. This is where reactive programming comes in. All of the code inside the dataTaskPublisher has not executed yet. We have simply returned a publisher who is waiting for a subscriber to come along and listen. A publisher will not execute unless a subscription has not been fulfilled. To subscribe to a stream we use the sink method. If you think of the chain of reactive methods flowing into a sink at the bottom, that is the best analogy here.\n  The sink method has 2 parts. The first closure defines what happens once the stream is completed. Now this can come in the form of a finished state, which means the stream has completed what is doing and will no longer emit any more events. Or failure, which means some item further up the stream has raised an error which flows down into this sink where it can be handled.\n  The second closure defines what we would like to do each time the event stream emits a change. In this case the publisher will send a users array once it has finished loading, here we are just printing out the user names.\n\n\nFinally\n\nWhat have we learnt:\n\n\n  We have used QuickType to convert our JSON into codable structs for decoding.\n  Wrapped the existing URLSession dataTask method with our own using Generics so we can using any Codable type to decode the response.\n  Similarly, using reactive programming and Apple’s new Combine framework have created our own Generic wrapper for the existing dataTaskPublisher function.\n\n\nFeel free to download the playground and play around with the examples yourself\n",
      tags: ["swift","combine","generics","networking"],
      id: 4
    });
    

    index.add({
      title: "What is type erasure in Swift",
      category: ["type-erasure"],
      content: "Intro\n\n\n  Wtf is type erasure?\n  Why do I need it?\n  This seems complicated?\n  Isn’t there a simpler way?\n\n\nThese are are just some of the questions I found myself asking once I first starting exploring type erasure. Like many other developers, I have been making use of protocols in my code to remove dependencies and make my classes easy to unit test. It wasn’t until I then started to add generics to my protocols that I discovered the need to apply type erasure.\n\nHaving read many blog posts and guides about type erasure I still came away confused as to what it was, why it was needed and why it seemed to add so much complexity. By trying to add generics to protocols in a project I was working on I finally saw the light! I am going to try and walk you through the topic using an example which is similar to the one I was trying to solve in my project. Hopefully this will help those of you who are looking to understand the topic further in the same way it helped me.\n\nGenerics and Associated Types\n\nI am assuming that as you are here you have a fairly advanced knowledge of Swift and have potentially begun or have been using protocols with generics in your code. Below is a simple protocol called Fetchable. The idea of the protocol is to go and fetch some objects of type FetchType from somewhere and call the completion handler with the result once it’s finished whatever it is doing.\n\nprotocol Fetchable {\n    associatedtype FetchType\n\n    func fetch(completion: ((Result&lt;FetchType, Error&gt;) -&gt; Void)?)\n}\n\nNow that we have our protocols lets create a couple of structs to implement the protocol.\n\nstruct User {\n    let id: Int\n    let name: String\n}\n\nstruct UserFetch: Fetchable {\n    typealias FetchType = User\n\n    func fetch(completion: ((Result&lt;FetchType, Error&gt;) -&gt; Void)?) {\n        let user = User(id: 1, name: \"Phil\")\n        completion?(.success(user))\n    }\n}\n\nSo here we have created a dummy data class, User. Our fetch struct has implemented the generic protocol and has specified the type of object that will be returned in the protocol using a typealias. Everything here is great, we can implement this protocol as many times as we like and return whatever object types we want without the need to create a new protocol for each one.\n\nThe problem\n\nNow, here in lies the problem. If we wish to hold a reference to an object that has implemented this protocol. How do we know what type it is going to return? See the below example:\n\nstruct SomeStruct {\n    let userFetch: Fetchable\n}\n\nWhat you will also find here is that you will see an error, something like the below\n\n\n  Protocol ‘Fetchable’ can only be used as a generic constraint because it has Self or associated type requirements\n\n\nSo we can’t even use this type as a reference to the object, as it has an associated type which we cannot see at this point and have no way of specifying.\n\nNow we could do something like below, however this creates a dependency between SomeStruct and the userFetch object. If we are following the SOLID principles we want to avoid having dependencies and hide implementation details.\n\nstruct SomeStruct {\n    let userFetch: UserFetch\n}\n\nOk, so let’s try adding a type like we do with other generic types such as arrays and dictionaries:\n\nstruct SomeStruct {\n    let userFetch: Fetchable&lt;User&gt;\n}\n\nIf you try the above you will probably end up with an error something like this:\n\n\n  Cannot specialize non-generic type ‘Fetchable’\n\n\nSee generic protocols, unlike generic types cannot have their type inferred in the type declaration. The type is only specified during implementation.\n\nType Erasure to the rescue\n\nSo this is where type erasure comes in. In order for us to know the type returned we need to implement a new class that can be used to infer the type of object returned so that we know what to expect when we call fetch.\n\n// 1\nstruct AnyFetchable&lt;T&gt;: Fetchable {\n    // 2\n    typealias FetchType = T\n\n    // 3\n    private let _fetch: (((Result&lt;T, Error&gt;) -&gt; Void)?) -&gt; Void\n\n    // 4\n    init&lt;U: Fetchable&gt;(_ fetchable: U) where U.FetchType == T {\n        _fetch = fetchable.fetch\n    }\n\n    // 5\n    func fetch(completion: ((Result&lt;T, Error&gt;) -&gt; Void)?) {\n        _fetch(completion)\n    }\n}\n\nWhoooa! There is a lot going on here so let us go through it piece by piece to explain what is happening.\n\n\n  Here our AnyFetchable class is implementing the Fetchable protocol. But also we see that we now have a generic type specification. This means that we can specify what type is being used while storing a reference to this struct.\n  Our generic type T being specified in the line above is then used in the typealias and mapped to the FetchType associated value of the protocol.\n  Now this is where things get fiddly. In order for us to erase the type of the injected class we must first create an attribute which is a closure with a matching signature for each function in the protocol. In this scenario we only have 1 method which is the fetch method. Here you can see the fetch attribute has the same method signature as the one in the protocol.\n  Lets break this down a bit. First of all we are saying that this init method is only available for an object that has implemented Fetchable, called U. The where clause at the end of the line is a generic type restriction which states that the FetchType of the Fetchable U must be the same as the one being used in this class. This might not make too much sense right now, but stay with me. When the fetchable type U is passed in, we store a reference to its fetch method in our own internal variable. This is what helps us erase the type, we store a reference to all of the objects methods without actually storing a reference to the object. That way we don’t need to know the type.\n  Here is our implementation of the Fetchable protocols fetch method, however all we are doing is calling the reference to passed in objects fetch method and calling that instead.\n\n\nHopefully some of this makes sense, some of this may be new or confusing especially point 4. Let’s show how we can use our class in this example.\n\nstruct SomeStruct {\n    let userFetch: AnyFetchable&lt;User&gt;\n}\n\n// 1\nlet userFetch = UserFetch()\n\n// 2\nlet anyFetchable = AnyFetchable&lt;User&gt;(userFetch)\n\n// 3\nlet someStruct = SomeStruct(userFetch: anyFetchable)\n\n// 4\nsomeStruct.userFetch.fetch { (result) in\n    switch result {\n    case .success(let user):\n        print(user.name)\n    case .failure(let error):\n        print(error)\n    }\n}\n\n\n  First we create an instance of our UserFetch object from earlier in the example that returns our example user.\n  We pass this into our AnyFetchable object. Now remember we had a generic type constraint on our init in point 4 of the previous example. This is being satisfied because we have specified that the AnyFetchable should return a User type, and the UserFetch object we are passing in has the FetchType User.\n  We can now pass in the AnyFetchable to our struct.\n\n\nWhy?\n\nNow you are probably thinking, why do all of this? Well, let’s try another example:\n\n// New Dave user struct\nstruct DaveFetch: Fetchable {\n    typealias FetchType = User\n\n    func fetch(completion: ((Result&lt;FetchType, Error&gt;) -&gt; Void)?) {\n        let user = User(id: 2, name: \"Dave\")\n        completion?(.success(user))\n    }\n}\n\n// Example implementation 2\nlet daveFetch = DaveFetch()\nlet anyDaveFetchable = AnyFetchable&lt;User&gt;(daveFetch)\nlet someDaveStruct = SomeStruct(userFetch: anyDaveFetchable)\n\nsomeDaveStruct.userFetch.fetch { (result) in\n    switch result {\n    case .success(let user):\n        print(user.name)\n    case .failure(let error):\n        print(error)\n    }\n}\n\nSo here we have created a new object that implements Fetchable and returns a user called Dave. We can then pass this into our SomeStruct using our type erasure class and it works exactly the same. The SomeStruct class doesn’t need to be changed in order to work with the new dave class as it’s type has been erased. In a production app we could inject any class we want as long as it fetches a User, whether that comes from the web, core data, the file system. It doesn’t matter we could switch it at any time without making changes to our SomeStruct class.\n\nFinally\n\nThe last example here is that we can use our Any class for other types, not just User. See the example below:\n\n// Product Type\nstruct Product {\n    let id: Int\n    let title: String\n    let price: String\n}\n\nstruct ProductFetch: Fetchable {\n    typealias FetchType = Product\n\n    func fetch(completion: ((Result&lt;FetchType, Error&gt;) -&gt; Void)?) {\n        let product = Product(id: 1, title: \"My Product\", price: \"10.99\")\n        completion?(.success(product))\n    }\n}\n\nlet productFetch = ProductFetch()\nlet anyProductFetch = AnyFetchable&lt;Product&gt;(productFetch)\nanyProductFetch.fetch { (result) in\n    switch result {\n    case .success(let product):\n        print(product.title)\n    case .failure(let error):\n        print(error)\n    }\n}\n\nSimilar to our user example, we have created a new Product object and a fetcher that returns a product object. However we can re-use our AnyFetchable here but specifying the return type as Product.\n\nThere is a lot to cover and understand here and hopefully this helps make some sense of type erasure and what it is used for. More importantly how to implement your own Any type erasure class for your own protocols so that they can be referenced in your code.\n\nDownload the playground and play around with the examples yourself\n",
      tags: ["swift","advanced","protocols","generics"],
      id: 5
    });
    


var store = [{
    "title": "Weekly Mobile Digest - 12 Feb 2021",
    "link": "/news/weekly-mobile-digest.html",
    "image": null,
    "date": "February 12, 2021",
    "category": ["News"],
    "excerpt": "Hyundai says it is not in talks with Apple to make self-driving cars We keep hearing lots of interesting rumours..."
},{
    "title": "Using protocols, ObservableObject and @Published property wrappers in SwiftUI",
    "link": "/swiftui/using-protocols-observableobject-published-property-wrappers-swiftui.html",
    "image": null,
    "date": "February 9, 2021",
    "category": ["SwiftUI"],
    "excerpt": "Background As I’m sure any iOS developer now knows, the future of iOS app development is SwiftUI. Apple’s new UI..."
},{
    "title": "Repository Pattern in Swift",
    "link": "/architecture/repository-pattern-in-swift-and-combine.html",
    "image": null,
    "date": "July 19, 2020",
    "category": ["architecture"],
    "excerpt": "Background All apps developed require data of some description. This data is stored somewhere, could be on the device itself,..."
},{
    "title": "Simple offline caching in Swift and Combine",
    "link": "/networking/simple-offline-caching-in-swift-and-combine.html",
    "image": null,
    "date": "July 1, 2020",
    "category": ["networking"],
    "excerpt": "Background Following on from the previous post where we explored simple JSON decoding. In this post we are going to..."
},{
    "title": "Simple JSON decoder in Swift and Combine",
    "link": "/networking/simple-json-decoder-in-swift-and-combine.html",
    "image": null,
    "date": "June 11, 2020",
    "category": ["networking"],
    "excerpt": "Intro Pretty much every app nowadays requires you to connect to the internet to access some content. The majority of..."
},{
    "title": "What is type erasure in Swift",
    "link": "/type-erasure/what-is-type-erasure.html",
    "image": null,
    "date": "June 3, 2020",
    "category": ["type-erasure"],
    "excerpt": "Intro Wtf is type erasure? Why do I need it? This seems complicated? Isn’t there a simpler way? These are..."
}]

$(document).ready(function() {
    $('#search-input').on('keyup', function () {
        var resultdiv = $('#results-container');
        if (!resultdiv.is(':visible'))
            resultdiv.show();
        var query = $(this).val();
        var result = index.search(query);
        resultdiv.empty();
        $('.show-results-count').text(result.length + ' Results');
        for (var item in result) {
            var ref = result[item].ref;
            var searchitem = '<li><a href="'+ hostname + store[ref].link+'">'+store[ref].title+'</a></li>';
            resultdiv.append(searchitem);
        }
    });
});