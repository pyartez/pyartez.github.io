var hostname = "http://localhost:4000";
var index = lunr(function () {
    this.field('title')
    this.field('content', {boost: 10})
    this.field('category')
    this.field('tags')
    this.ref('id')
});



    index.add({
      title: "Simple JSON decoder in Swift and Combine",
      category: ["Codable"],
      content: "Intro\n\nPretty much every app nowadays requires you to connect to the internet to access some content. The majority of those apps use JSON to communicate that data from the backend systems.\n\nThere is high chance you will have some code in your app to download, parse and return objects for your app to use from an endpoint (unless you are using a network library such as Alamofire)\n\nIn this post we are going to demonstrate how we can use Generics and Codable to help us build a simple reusable JSON decoder to download and parse responses from our endpoints.\n\nBuilding our codable objects\n\nThe first thing we need to do is build our codable objects. Objects that implement the Codable protocol allow Encoders and Decoders to encode or decode them to and from an external representation such as JSON.\n\nLet’s take the response from the sample endpoint below as an example:\n\nhttps://jsonplaceholder.typicode.com/users\n\n{\n    \"id\": 1,\n    \"name\": \"Leanne Graham\",\n    \"username\": \"Bret\",\n    \"email\": \"Sincere@april.biz\",\n    \"address\": {\n      \"street\": \"Kulas Light\",\n      \"suite\": \"Apt. 556\",\n      \"city\": \"Gwenborough\",\n      \"zipcode\": \"92998-3874\",\n      \"geo\": {\n        \"lat\": \"-37.3159\",\n        \"lng\": \"81.1496\"\n      }\n    },\n    \"phone\": \"1-770-736-8031 x56442\",\n    \"website\": \"hildegard.org\",\n    \"company\": {\n      \"name\": \"Romaguera-Crona\",\n      \"catchPhrase\": \"Multi-layered client-server neural-net\",\n      \"bs\": \"harness real-time e-markets\"\n    }\n  }\n\nYou can create codable classes yourself by hand. In simple examples this can be fairly straight forward, however if you have a response that has a more complex structure, doing so can be time consuming and error prone.\n\nTo create our codable objects we can use a generator, my weapon of choice is QuickType. We just paste in the JSON that is returned from the posts endpoint and it automatically generates the Codable structs for us. Easy!\n\nIf we paste in our post response, we should end up with some code looking like this:\n\n// MARK: - User\nstruct User: Codable {\n    let id: Int\n    let name, username, email: String\n    let address: Address\n    let phone, website: String\n    let company: Company\n}\n\n// MARK: - Address\nstruct Address: Codable {\n    let street, suite, city, zipcode: String\n    let geo: Geo\n}\n\n// MARK: - Geo\nstruct Geo: Codable {\n    let lat, lng: String\n}\n\n// MARK: - Company\nstruct Company: Codable {\n    let name, catchPhrase, bs: String\n}\n\ntypealias Users = [User]\n\nHow easy was that?! Obviously we will still need to check the structs, in the example above none of the fields are optional which means data must be passed in otherwise our decoding will fail. We don’t need to worry about that here, but worth remembering when checking the generated code in your examples.\n\nURLSession extension and Generics\n\nTo solve our problem we are going to wrap the existing URLSession dataTask method. I’m sure if you have done any kind of request work in pure swift you will have used this method in some form so we aren’t going to go into the details of how it works.\n\nextension URLSession {\n\n\t// 1\n    enum SessionError: Error {\n        case noData\n        case statusCode\n    }\n\n    /// Wraps the standard dataTask method with a JSON decode attempt using the passed generic type.\n    /// Throws an error if decoding fails\n    /// - Parameters:\n    ///   - url: The URL to be retrieved.\n    ///   - completionHandler: The completion handler to be called once decoding is complete / fails\n    /// - Returns: The new session data task\n\n    // 2 \n    func dataTask&lt;T: Decodable&gt;(with url: URL,\n                                completionHandler: @escaping (T?, URLResponse?, Error?) -&gt; Void) -&gt; URLSessionDataTask {\n\n        // 3\n        return self.dataTask(with: url) { (data, response, error) in\n        \t// 4\n            guard error == nil else {\n                completionHandler(nil, response, error)\n                return\n            }\n\n            // 5\n            if let response = response as? HTTPURLResponse,\n                (200..&lt;300).contains(response.statusCode) == false {\n                completionHandler(nil, response, SessionError.statusCode)\n            }\n\n            // 6\n            guard let data = data else {\n                completionHandler(nil, response, SessionError.noData)\n                return\n            }\n\n            // 7\n            do {\n                let decoded = try JSONDecoder().decode(T.self, from: data)\n                completionHandler(decoded, response, nil)\n            } catch(let error) {\n                completionHandler(nil, response, error)\n            }\n        }\n    }\n}\n\nSo let’s step through this code sample step by step:\n\n\n  First of we have defined a custom error for this extension, this is returned when no data has been returned from the request, covered in point 6. We also have an error case if we get an HTTPURLResponse with an incorrect status code, covered in point 5.\n  Here we are making use of Generics to allow any type T being returned from this function as long as type T implements the Decodable protocol (which we need it to inorder to use the JSONDecoder)\n  As discussed, here we are calling the existing dataTask method to run our request.\n  First thing we do once the request has returned is check to see if there was a request error, if so we call the completion handler with the response and the error.\n  The second check we perform is to check the status code if we have received an HTTPURLResponse. Note we aren’t stopping the code here if we don’t get a HTTPURLResponse as you could use this function to load a local JSON file for example, not just a remote URL. Any status code in the 200-299 range is considered a successful request, if we receive a status code outside this range we return an error along with the response for further processing by whoever passed the completion handler.\n  The third check we perform is to unwrap data ready for decoding. If this fails (as in it’s nil) then we call the completionHandler with the response and our custom error defined in step 1.\n  The final piece of the puzzle is to attempt to decode the data into type T we defined in the method signature as part of step 2. If this succeeds we can call our completion handler with our decoded type and response. If it throws an error we capture the error and return it using the catch block below.\n\n\nSee it in action\n\nNow that we have put our function together, let’s take it for a test drive.\n\nlet url = URL(string: \"https://jsonplaceholder.typicode.com/users\")!\nlet task = URLSession.shared.dataTask(with: url, completionHandler: { (users: Users?, response, error) in\n    if let error = error {\n        print(error.localizedDescription)\n        return\n    }\n\n    users?.forEach({ print(\"\\($0.name)\\n\") })\n})\ntask.resume()\n\nThis shouldn’t look too scarey, infact if you have used the standard dataTask functions in your code previously this should look very familiar. The only different here being that our completion handler now returns our Codable User objects rather than just a blob of Data like before.\n\nHopefully that example makes sense and gives you a nice simple way to perform a request and have it decode some JSON into a struct / class. Now let’s have a look at some reactive programming using Combine.\n\nCombine\n\nHopefully you have at least heard of Combine even if you haven’t had chance to use it yet in a production app. It is Apple’s own version of a reactive framework. Those of you who have already been using RxSwift will be right at home. We aren’t going to go into too much detail about what Combine is but here is a definition of what reactive programming is:\n\n\n  In computing, reactive programming is a declarative programming paradigm concerned with data streams and the propagation of change\n\n\nIn more simplistic terms, reactive programming uses a observer pattern to allow classes to monitor different streams of data or state. When this state changes it emits an event with the new value which can trigger other streams to perform work or update such as UI code. If you are familier with KVO you will understand the basic concept. However reactive programming is far less painful and a lot more powerful than KVO.\n\nNow let’s take the previous pure Swift example and see how we can use it in Combine. The Combine framework adds new reactive functionality to the URLSession in the form of the dataTaskPublisher function.\n\nextension URLSession {\n\n\t// 1\n    enum SessionError: Error {\n        case statusCode(HTTPURLResponse)\n    }\n\n    /// Function that wraps the existing dataTaskPublisher method and attempts to decode the result and publish it\n    /// - Parameter url: The URL to be retrieved.\n    /// - Returns: Publisher that sends a DecodedResult if the response can be decoded correctly.\n\n    // 2\n    func dataTaskPublisher&lt;T: Decodable&gt;(for url: URL) -&gt; AnyPublisher&lt;T, Error&gt; {\n    \t// 3\n        return self.dataTaskPublisher(for: url)\n        \t// 4\n            .tryMap({ (data, response) -&gt; Data in\n                if let response = response as? HTTPURLResponse,\n                    (200..&lt;300).contains(response.statusCode) == false {\n                    throw SessionError.statusCode(response)\n                }\n\n                return data\n            })\n            // 5\n            .decode(type: T.self, decoder: JSONDecoder())\n            // 6\n            .eraseToAnyPublisher()\n    }\n}\n\nSimilar to our previous example we have extended URLSession to provide this functionality. Let’s step through it:\n\n\n  As with the pure Swift example we are defining a custom error here to handle when we receive a status code that is not a success. The difference being here we are attaching the response to the error as we don’t have a completionHandler in Combine. That way whoever is handling the error can inspect the response and see why it failed.\n  Here we are defining the method, again using generics to only accept a type T that has implemented the  Decodable protocol. The function returns a publisher who returns our decoded object.\n  As discussed previously, we are simply wrapping the existing dataTaskPublisher method.\n  Now here is where things start to become reactive. The tryMap function is similar to the standard map function in that it attempts to convert / transfrom elements from one type to another. However the difference here being that it is almost wrapped in a try. In this case you can include code in the closure which throws errors and they will be pushed downstream and handled later instead of needing a do block. Similar to our pure Swift example, we are checking we have a valid status code, if not we throw our custom error. If not we map our data ready to be decoded.\n  Here we are using the built in decode method to attempt to decode our custom type using the JSONDecoder. Similar to the tryMap function above, any errors are pushed downstream to be handler later.\n  The final piece of the puzzle is to use type erasure. This removes the publisher class type and makes it AnyPublisher. For more info on type erasure see my previous post\n\n\nCombine in action\n\nNow that we have built our wrapper class let’s take a look at this in action:\n\nlet url = URL(string: \"https://jsonplaceholder.typicode.com/users\")!\n\nlet token = URLSession.shared.dataTaskPublisher(for: url)\n\t// 1\n    .sink(receiveCompletion: { (completion) in\n        switch completion {\n        // 2\n        case .finished:\n            break\n        case .failure(let error):\n            print(error.localizedDescription)\n        }\n    }) { (users: Users) in\n    \t// 3\n        users.forEach({ print(\"\\($0.name)\\n\") })\n    }\n\n\n  Here we have called our newly created dataTaskPublisher method which has returned our publisher. This is where reactive programming comes in. All of the code inside the dataTaskPublisher has not executed yet. We have simply returned a publisher who is waiting for a subscriber to come along and listen. A publisher will not execute unless a subscription has not been fulfilled. To subscribe to a stream we use the sink method. If you think of the chain of reactive methods flowing into a sink at the bottom, that is the best analogy here.\n  The sink method has 2 parts. The first closure defines what happens once the stream is completed. Now this can come in the form of a finished state, which means the stream has completed what is doing and will no longer emit any more events. Or failure, which means some item further up the stream has raised an error which flows down into this sink where it can be handled.\n  The second closure defines what we would like to do each time the event stream emits a change. In this case the publisher will send a users array once it has finished loading, here we are just printing out the user names.\n\n\nFinally\n\nWhat have we learnt:\n\n\n  We have used QuickType to convert our JSON into codable structs for decoding.\n  Wrapped the existing URLSession dataTask method with our own using Generics so we can using any Codable type to decode the response.\n  Similarly, using reactive programming and Apple’s new Combine framework have created our own Generic wrapper for the existing dataTaskPublisher function.\n\n\nFeel free to download the playground and play around with the examples yourself\n",
      tags: ["swift","combine","generics","networking"],
      id: 0
    });
    

    index.add({
      title: "What is type erasure in Swift",
      category: ["type-erasure"],
      content: "Intro\n\n\n  Wtf is type erasure?\n  Why do I need it?\n  This seems complicated?\n  Isn’t there a simpler way?\n\n\nThese are are just some of the questions I found myself asking once I first starting exploring type erasure. Like many other developers, I have been making use of protocols in my code to remove dependencies and make my classes easy to unit test. It wasn’t until I then started to add generics to my protocols that I discovered the need to apply type erasure.\n\nHaving read many blog posts and guides about type erasure I still came away confused as to what it was, why it was needed and why it seemed to add so much complexity. By trying to add generics to protocols in a project I was working on I finally saw the light! I am going to try and walk you through the topic using an example which is similar to the one I was trying to solve in my project. Hopefully this will help those of you who are looking to understand the topic further in the same way it helped me.\n\nGenerics and Associated Types\n\nI am assuming that as you are here you have a fairly advanced knowledge of Swift and have potentially begun or have been using protocols with generics in your code. Below is a simple protocol called Fetchable. The idea of the protocol is to go and fetch some objects of type FetchType from somewhere and call the completion handler with the result once it’s finished whatever it is doing.\n\nprotocol Fetchable {\n    associatedtype FetchType\n\n    func fetch(completion: ((Result&lt;FetchType, Error&gt;) -&gt; Void)?)\n}\n\nNow that we have our protocols lets create a couple of structs to implement the protocol.\n\nstruct User {\n    let id: Int\n    let name: String\n}\n\nstruct UserFetch: Fetchable {\n    typealias FetchType = User\n\n    func fetch(completion: ((Result&lt;FetchType, Error&gt;) -&gt; Void)?) {\n        let user = User(id: 1, name: \"Phil\")\n        completion?(.success(user))\n    }\n}\n\nSo here we have created a dummy data class, User. Our fetch struct has implemented the generic protocol and has specified the type of object that will be returned in the protocol using a typealias. Everything here is great, we can implement this protocol as many times as we like and return whatever object types we want without the need to create a new protocol for each one.\n\nThe problem\n\nNow, here in lies the problem. If we wish to hold a reference to an object that has implemented this protocol. How do we know what type it is going to return? See the below example:\n\nstruct SomeStruct {\n    let userFetch: Fetchable\n}\n\nWhat you will also find here is that you will see an error, something like the below\n\n\n  Protocol ‘Fetchable’ can only be used as a generic constraint because it has Self or associated type requirements\n\n\nSo we can’t even use this type as a reference to the object, as it has an associated type which we cannot see at this point and have no way of specifying.\n\nNow we could do something like below, however this creates a dependency between SomeStruct and the userFetch object. If we are following the SOLID principles we want to avoid having dependencies and hide implementation details.\n\nstruct SomeStruct {\n    let userFetch: UserFetch\n}\n\nOk, so let’s try adding a type like we do with other generic types such as arrays and dictionaries:\n\nstruct SomeStruct {\n    let userFetch: Fetchable&lt;User&gt;\n}\n\nIf you try the above you will probably end up with an error something like this:\n\n\n  Cannot specialize non-generic type ‘Fetchable’\n\n\nSee generic protocols, unlike generic types cannot have their type inferred in the type declaration. The type is only specified during implementation.\n\nType Erasure to the rescue\n\nSo this is where type erasure comes in. In order for us to know the type returned we need to implement a new class that can be used to infer the type of object returned so that we know what to expect when we call fetch.\n\n// 1\nstruct AnyFetchable&lt;T&gt;: Fetchable {\n    // 2\n    typealias FetchType = T\n\n    // 3\n    private let _fetch: (((Result&lt;T, Error&gt;) -&gt; Void)?) -&gt; Void\n\n    // 4\n    init&lt;U: Fetchable&gt;(_ fetchable: U) where U.FetchType == T {\n        _fetch = fetchable.fetch\n    }\n\n    // 5\n    func fetch(completion: ((Result&lt;T, Error&gt;) -&gt; Void)?) {\n        _fetch(completion)\n    }\n}\n\nWhoooa! There is a lot going on here so let us go through it piece by piece to explain what is happening.\n\n\n  Here our AnyFetchable class is implementing the Fetchable protocol. But also we see that we now have a generic type specification. This means that we can specify what type is being used while storing a reference to this struct.\n  Our generic type T being specified in the line above is then used in the typealias and mapped to the FetchType associated value of the protocol.\n  Now this is where things get fiddly. In order for us to erase the type of the injected class we must first create an attribute which is a closure with a matching signature for each function in the protocol. In this scenario we only have 1 method which is the fetch method. Here you can see the fetch attribute has the same method signature as the one in the protocol.\n  Lets break this down a bit. First of all we are saying that this init method is only available for an object that has implemented Fetchable, called U. The where clause at the end of the line is a generic type restriction which states that the FetchType of the Fetchable U must be the same as the one being used in this class. This might not make too much sense right now, but stay with me. When the fetchable type U is passed in, we store a reference to its fetch method in our own internal variable. This is what helps us erase the type, we store a reference to all of the objects methods without actually storing a reference to the object. That way we don’t need to know the type.\n  Here is our implementation of the Fetchable protocols fetch method, however all we are doing is calling the reference to passed in objects fetch method and calling that instead.\n\n\nHopefully some of this makes sense, some of this may be new or confusing especially point 4. Let’s show how we can use our class in this example.\n\nstruct SomeStruct {\n    let userFetch: AnyFetchable&lt;User&gt;\n}\n\n// 1\nlet userFetch = UserFetch()\n\n// 2\nlet anyFetchable = AnyFetchable&lt;User&gt;(userFetch)\n\n// 3\nlet someStruct = SomeStruct(userFetch: anyFetchable)\n\n// 4\nsomeStruct.userFetch.fetch { (result) in\n    switch result {\n    case .success(let user):\n        print(user.name)\n    case .failure(let error):\n        print(error)\n    }\n}\n\n\n  First we create an instance of our UserFetch object from earlier in the example that returns our example user.\n  We pass this into our AnyFetchable object. Now remember we had a generic type constraint on our init in point 4 of the previous example. This is being satisfied because we have specified that the AnyFetchable should return a User type, and the UserFetch object we are passing in has the FetchType User.\n  We can now pass in the AnyFetchable to our struct.\n\n\nWhy?\n\nNow you are probably thinking, why do all of this? Well, let’s try another example:\n\n// New Dave user struct\nstruct DaveFetch: Fetchable {\n    typealias FetchType = User\n\n    func fetch(completion: ((Result&lt;FetchType, Error&gt;) -&gt; Void)?) {\n        let user = User(id: 2, name: \"Dave\")\n        completion?(.success(user))\n    }\n}\n\n// Example implementation 2\nlet daveFetch = DaveFetch()\nlet anyDaveFetchable = AnyFetchable&lt;User&gt;(daveFetch)\nlet someDaveStruct = SomeStruct(userFetch: anyDaveFetchable)\n\nsomeDaveStruct.userFetch.fetch { (result) in\n    switch result {\n    case .success(let user):\n        print(user.name)\n    case .failure(let error):\n        print(error)\n    }\n}\n\nSo here we have created a new object that implements Fetchable and returns a user called Dave. We can then pass this into our SomeStruct using our type erasure class and it works exactly the same. The SomeStruct class doesn’t need to be changed in order to work with the new dave class as it’s type has been erased. In a production app we could inject any class we want as long as it fetches a User, whether that comes from the web, core data, the file system. It doesn’t matter we could switch it at any time without making changes to our SomeStruct class.\n\nFinally\n\nThe last example here is that we can use our Any class for other types, not just User. See the example below:\n\n// Product Type\nstruct Product {\n    let id: Int\n    let title: String\n    let price: String\n}\n\nstruct ProductFetch: Fetchable {\n    typealias FetchType = Product\n\n    func fetch(completion: ((Result&lt;FetchType, Error&gt;) -&gt; Void)?) {\n        let product = Product(id: 1, title: \"My Product\", price: \"10.99\")\n        completion?(.success(product))\n    }\n}\n\nlet productFetch = ProductFetch()\nlet anyProductFetch = AnyFetchable&lt;Product&gt;(productFetch)\nanyProductFetch.fetch { (result) in\n    switch result {\n    case .success(let product):\n        print(product.title)\n    case .failure(let error):\n        print(error)\n    }\n}\n\nSimilar to our user example, we have created a new Product object and a fetcher that returns a product object. However we can re-use our AnyFetchable here but specifying the return type as Product.\n\nThere is a lot to cover and understand here and hopefully this helps make some sense of type erasure and what it is used for. More importantly how to implement your own Any type erasure class for your own protocols so that they can be referenced in your code.\n\nDownload the playground and play around with the examples yourself\n",
      tags: ["swift","advanced","protocols","generics"],
      id: 1
    });
    


var store = [{
    "title": "Simple JSON decoder in Swift and Combine",
    "link": "/codable/simple-json-decoder-in-swift-and-combine.html",
    "image": null,
    "date": "June 11, 2020",
    "category": ["Codable"],
    "excerpt": "Intro Pretty much every app nowadays requires you to connect to the internet to access some content. The majority of..."
},{
    "title": "What is type erasure in Swift",
    "link": "/type-erasure/what-is-type-erasure.html",
    "image": null,
    "date": "June 3, 2020",
    "category": ["type-erasure"],
    "excerpt": "Intro Wtf is type erasure? Why do I need it? This seems complicated? Isn’t there a simpler way? These are..."
}]

$(document).ready(function() {
    $('#search-input').on('keyup', function () {
        var resultdiv = $('#results-container');
        if (!resultdiv.is(':visible'))
            resultdiv.show();
        var query = $(this).val();
        var result = index.search(query);
        resultdiv.empty();
        $('.show-results-count').text(result.length + ' Results');
        for (var item in result) {
            var ref = result[item].ref;
            var searchitem = '<li><a href="'+ hostname + store[ref].link+'">'+store[ref].title+'</a></li>';
            resultdiv.append(searchitem);
        }
    });
});